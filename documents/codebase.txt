Directory Structure:
coffee-app-api/
  pom.xml
  coffee-app-backend/
    openapi.json
    src/
      main/
        resources/
          application.properties
          db/
            migration/
              h2/
                V1_1_4__Add_OrderPlacedOn_Column.sql
                V1_0_0__Add_Schema.sql
                V1_1_2__Add_Products.sql
                V1_1_0__Add_SugarTypes.sql
                V1_1_1__Add_ExtraTypes.sql
                V1_1_6__Add_Contacts.sql
                V1_1_5__Add_Users.sql
                V1_1_3__Add_EmailTemplates.sql
        java/
          com/
            theexperts/
              coffeeappbackend/
                business/
                  EmailTemplateService.java
                  ContactNotFoundException.java
                  DefaultOrderService.java
                  RabbitMQServiceBus.java
                  MessageBus.java
                  DefaultCustomerService.java
                  DefaultProductService.java
                  dataobjects/
                    OrderModel.java
                    ExtraTypeModel.java
                    OrderModelStatus.java
                    OrderItemCreateModel.java
                    ContactModel.java
                    OrderItemModel.java
                    OrderProduct.java
                    PageResult.java
                    EmailTemplateModel.java
                    CustomerCreateModel.java
                    UserCreateModel.java
                    UserModel.java
                    CustomerModel.java
                    ContactCreateModel.java
                    SugarTypeModel.java
                    OrderCreateModel.java
                    ProductModel.java
                  CustomerMapper.java
                  contactresolution/
                    ContactResolver.java
                    DefaultContactResolver.java
                    ContactResolveContext.java
                  SugarTypeFilter.java
                  AzureServiceBus.java
                  SortDirection.java
                  ContactMapper.java
                  DefaultNewsletterService.java
                  OrderNotFoundException.java
                  DefaultExtraTypeService.java
                  OrderStatuses.java
                  UserMapper.java
                  CustomerService.java
                  CustomerNotFoundException.java
                  OrderService.java
                  OrderFilter.java
                  DefaultEmailTemplateService.java
                  NewsletterService.java
                  DefaultContactService.java
                  DefaultUserService.java
                  UserService.java
                  ExtraTypeService.java
                  SugarTypeService.java
                  ExtraTypeFilter.java
                  UserNotFoundException.java
                  ContactService.java
                  ProductFilter.java
                  ProductService.java
                  DefaultSugarTypeService.java
                templates/
                  TemplateService.java
                  handlebars/
                    HandlebarsTemplateService.java
                  TemplateServiceContext.java
                persistence/
                  repository/
                    UserRepository.java
                    EmailTemplateRepository.java
                    OrdersRepository.java
                    SugarTypesRepository.java
                    ExtraTypesRepository.java
                    OrderItemsRepository.java
                    ProductRepository.java
                    SubscriptionSchemeRepository.java
                    ContactRepository.java
                    CustomerRepository.java
                  Constants.java
                  entities/
                    Product.java
                    EmailTemplate.java
                    ChannelType.java
                    ExtraType.java
                    User.java
                    Customer.java
                    SugarType.java
                    SubscriptionScheme.java
                    Contact.java
                    OrderStatus.java
                    Order.java
                    OptInOut.java
                    OrderItem.java
                mail/
                  sendgrid/
                    SendgridMailServiceOptions.java
                    SendgridMailService.java
                  ConsoleMailService.java
                  SendMailContext.java
                  MailService.java
                Application.java
                web/
                  GlobalExceptionHandler.java
                  ValidationException.java
                  pages/
                    Page.java
                    PagesValidator.java
                    PageValidator.java
                    PageSizeValidator.java
                    PageSize.java
                  model/
                    RemoveSubscriptionRequest.java
                    OrderCreateRequest.java
                    AddSubscriptionRequest.java
                    SubscriptionRequest.java
                    ContactCreateRequest.java
                  controller/
                    SugarTypeController.java
                    OrderController.java
                    ProductController.java
                    ContactController.java
                    ExtraTypeController.java
                    OrderCreateRequestValidator.java
                    HeaderMethodArgumentResolverConfiguration.java
                  ApplicationConfiguration.java
                  responses/
                    ErrorResponse.java
                    ValidationError.java
                    ValidationErrorResponse.java
                    GenericErrorResponse.java
                    ValidationErrorResponseBuilder.java
                    ErrorResponseBuilder.java
                  security/
                    SecurityConfiguration.java
                    DefaultUserDetailsService.java
                    JwtAuthorizationFilter.java
                    web/
                      model/
                        AuthenticationRequest.java
                        ResetPasswordRequest.java
                        UserCreateRequest.java
                      AuthenticationController.java
                    DefaultAuthenticationManager.java
                ObjectResult.java
                util/
                  TokenParseException.java
                  JwtService.java
                  JwtServiceOptions.java
                  StringUtils.java
    pom.xml

File Contents:

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.the-experts</groupId>
    <artifactId>coffee-app</artifactId>
    <version>0.0.1-local</version>
    <packaging>pom</packaging>

    <modules>
        <module>coffee-app-backend</module>
    </modules>

    <properties>
        <java.version>21</java.version>

        <maven-compiler-plugin.version>3.13.0</maven-compiler-plugin.version>
        <maven-surefire-plugin.version>3.5.1</maven-surefire-plugin.version>
        <jacoco-maven-plugin.version>0.8.12</jacoco-maven-plugin.version>
        <cyclonedx-maven-plugin.version>2.7.1</cyclonedx-maven-plugin.version>
    </properties>

    <build>
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>${maven-compiler-plugin.version}</version>
                    <configuration>
                        <source>${java.version}</source>
                        <release>${java.version}</release>
                    </configuration>
                </plugin>
                <plugin>
                    <groupId>org.jacoco</groupId>
                    <artifactId>jacoco-maven-plugin</artifactId>
                    <version>${jacoco-maven-plugin.version}</version>
                </plugin>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>${maven-surefire-plugin.version}</version>
                </plugin>

                <plugin>
                    <groupId>org.cyclonedx</groupId>
                    <artifactId>cyclonedx-maven-plugin</artifactId>
                    <version>${cyclonedx-maven-plugin.version}</version>
                    <executions>
                        <execution>
                            <phase>package</phase>
                            <goals>
                                <goal>makeAggregateBom</goal>
                            </goals>
                        </execution>
                    </executions>
                    <configuration>
                        <projectType>library</projectType>
                        <schemaVersion>1.4</schemaVersion>
                        <includeBomSerialNumber>true</includeBomSerialNumber>
                        <includeCompileScope>true</includeCompileScope>
                        <includeProvidedScope>true</includeProvidedScope>
                        <includeRuntimeScope>true</includeRuntimeScope>
                        <includeSystemScope>true</includeSystemScope>
                        <includeTestScope>false</includeTestScope>
                        <includeLicenseText>false</includeLicenseText>
                        <outputReactorProjects>true</outputReactorProjects>
                        <outputFormat>all</outputFormat>
                        <outputName>CycloneDX-Sbom</outputName>
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
</project>
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/openapi.json ---
{"openapi":"3.0.1","info":{"title":"OpenAPI definition","version":"v0"},"servers":[{"url":"http://localhost:8090","description":"Generated server url"}],"paths":{"/orders":{"get":{"tags":["order-controller"],"operationId":"getOrders","parameters":[{"name":"arg0","in":"query","required":true,"schema":{"$ref":"#/components/schemas/Page"}},{"name":"arg1","in":"query","required":true,"schema":{"$ref":"#/components/schemas/PageSize"}},{"name":"sortKey","in":"query","required":false,"schema":{"type":"string"}},{"name":"sortDirection","in":"query","required":false,"schema":{"type":"string"}},{"name":"status","in":"query","required":false,"schema":{"type":"string","enum":["PENDING","PROCESSING","AWAITING_PICKUP","COMPLETED","CANCELED"]}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageResultOrderModel"}}}}}},"post":{"tags":["order-controller"],"operationId":"createOrder","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/OrderCreateRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ObjectResultOrderModel"}}}}}}},"/orders/{id}/{status}":{"post":{"tags":["order-controller"],"operationId":"updateStatus","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"integer","format":"int32"}},{"name":"status","in":"path","required":true,"schema":{"type":"string","enum":["PENDING","PROCESSING","AWAITING_PICKUP","COMPLETED","CANCELED"]}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ObjectResultOrderModel"}}}}}}},"/contacts":{"post":{"tags":["contact-controller"],"operationId":"create","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ContactCreateRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ObjectResultObject"}}}}}}},"/contacts/unsubscribe":{"post":{"tags":["contact-controller"],"operationId":"unsubscribe","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/RemoveSubscriptionRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"boolean"}}}}}}},"/contacts/subscription/accept":{"post":{"tags":["contact-controller"],"operationId":"acceptSubscription","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AddSubscriptionRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"boolean"}}}}}}},"/contacts/subscribe":{"post":{"tags":["contact-controller"],"operationId":"subscribe","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SubscriptionRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"boolean"}}}}}}},"/account/reset":{"post":{"tags":["authentication-controller"],"operationId":"resetPassword","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ResetPasswordRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"object"}}}}}}},"/account/create":{"post":{"tags":["authentication-controller"],"operationId":"createUser","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UserCreateRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"object"}}}}}}},"/account/authenticate":{"post":{"tags":["authentication-controller"],"operationId":"authenticateUser","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/AuthenticationRequest"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"object"}}}}}}},"/sugartypes":{"get":{"tags":["sugar-type-controller"],"operationId":"getSugarTypes","parameters":[{"name":"arg0","in":"query","required":true,"schema":{"$ref":"#/components/schemas/Page"}},{"name":"arg1","in":"query","required":true,"schema":{"$ref":"#/components/schemas/PageSize"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/SugarTypeModel"}}}}}}}},"/products":{"get":{"tags":["product-controller"],"operationId":"getProducts","parameters":[{"name":"arg0","in":"query","required":true,"schema":{"$ref":"#/components/schemas/Page"}},{"name":"arg1","in":"query","required":true,"schema":{"$ref":"#/components/schemas/PageSize"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ProductModel"}}}}}}}},"/products/{id}":{"get":{"tags":["product-controller"],"operationId":"getProduct","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"integer","format":"int32"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ProductModel"}}}}}}},"/orders/{id}":{"get":{"tags":["order-controller"],"operationId":"getOrder","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"integer","format":"int32"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/OrderModel"}}}}}}},"/orders/count":{"get":{"tags":["order-controller"],"operationId":"getOrderStatistics","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"integer","format":"int64"}}}}}}},"/extratypes":{"get":{"tags":["extra-type-controller"],"operationId":"getExtraTypes","parameters":[{"name":"arg0","in":"query","required":true,"schema":{"$ref":"#/components/schemas/Page"}},{"name":"arg1","in":"query","required":true,"schema":{"$ref":"#/components/schemas/PageSize"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ExtraTypeModel"}}}}}}}}},"components":{"schemas":{"OrderCreateRequest":{"required":["email","fullName","productId","sugarTypeId"],"type":"object","properties":{"email":{"type":"string"},"fullName":{"type":"string"},"subscribe":{"type":"boolean"},"productId":{"type":"integer","format":"int32"},"sugarTypeId":{"type":"integer","format":"int32"},"extraTypeIds":{"type":"array","items":{"type":"integer","format":"int32"}}}},"CustomerModel":{"type":"object","properties":{"email":{"type":"string"},"fullName":{"type":"string"}}},"ObjectResultOrderModel":{"type":"object","properties":{"success":{"type":"boolean"},"data":{"$ref":"#/components/schemas/OrderModel"}}},"OrderItemModel":{"type":"object","properties":{"productName":{"type":"string"},"sugarType":{"type":"string"},"extraTypes":{"type":"array","items":{"type":"string"}}}},"OrderModel":{"type":"object","properties":{"id":{"type":"integer","format":"int32"},"status":{"type":"string","enum":["PENDING","PROCESSING","AWAITING_PICKUP","COMPLETED","CANCELED"]},"customer":{"$ref":"#/components/schemas/CustomerModel"},"orderItems":{"type":"array","items":{"$ref":"#/components/schemas/OrderItemModel"}}}},"ContactCreateRequest":{"required":["email","fullName"],"type":"object","properties":{"email":{"maxLength":250,"minLength":0,"type":"string"},"mobile":{"maxLength":250,"minLength":0,"type":"string"},"phone":{"maxLength":250,"minLength":0,"type":"string"},"fullName":{"maxLength":500,"minLength":0,"type":"string"}}},"ObjectResultObject":{"type":"object","properties":{"success":{"type":"boolean"},"data":{"type":"object"}}},"RemoveSubscriptionRequest":{"type":"object","properties":{"token":{"type":"string"}}},"AddSubscriptionRequest":{"type":"object","properties":{"token":{"type":"string"}}},"SubscriptionRequest":{"required":["email"],"type":"object","properties":{"email":{"maxLength":250,"minLength":0,"type":"string"}}},"ResetPasswordRequest":{"required":["password","resetToken","username"],"type":"object","properties":{"username":{"type":"string"},"password":{"type":"string"},"resetToken":{"type":"string"}}},"UserCreateRequest":{"required":["password","username"],"type":"object","properties":{"username":{"type":"string"},"password":{"type":"string"}}},"AuthenticationRequest":{"type":"object","properties":{"username":{"type":"string"},"password":{"type":"string"}}},"Page":{"type":"object"},"PageSize":{"type":"object"},"SugarTypeModel":{"type":"object","properties":{"id":{"type":"integer","format":"int32"},"name":{"type":"string"}}},"ProductModel":{"type":"object","properties":{"id":{"type":"integer","format":"int32"},"name":{"type":"string"}}},"PageResultOrderModel":{"type":"object","properties":{"count":{"type":"integer","format":"int64"},"items":{"type":"array","items":{"$ref":"#/components/schemas/OrderModel"}}}},"ExtraTypeModel":{"type":"object","properties":{"id":{"type":"integer","format":"int32"},"name":{"type":"string"}}}}}}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/application.properties ---
#debug=true
server.port=8090

#spring
spring.threads.virtual.enabled=true
#hibernate
spring.datasource.url=jdbc:h2:file:./coffee-orders;AUTO_SERVER=true
spring.datasource.username=root
spring.datasource.password=root!
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=none
#spring.jpa.show-sql=true
#spring.jpa.properties.hibernate.format_sql=true

#h2
spring.h2.console.enabled=true
spring.h2.console.settings.web-allow-others=true

# flyway
#spring.flyway.enabled=false
spring.flyway.baseline-on-migrate=true
spring.flyway.locations=classpath:db/migration/h2

# openapi
springdoc.swagger-ui.enabled=true

# mail
mail.provider=console

#servicebus
servicebus.platform=rabbitmq
servicebus.connection-string=amqp://guest:guest@$queue:5672

#jwt
jwt.issuer=the/experts
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_4__Add_OrderPlacedOn_Column.sql ---
ALTER TABLE `orders`
    ADD COLUMN IF NOT EXISTS `order_placed_on` DATETIME(6) NULL;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_0_0__Add_Schema.sql ---
--
-- Database: `coffee-orders`
--

-- --------------------------------------------------------

--
-- Table structure for table `customer`
--

CREATE TABLE IF NOT EXISTS `customer` (
    `id` int NOT NULL AUTO_INCREMENT,

    `email` varchar(250) NOT NULL,
    `full_name` varchar(350) NOT NULL,

    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,

    PRIMARY KEY (`id`),
    UNIQUE(`email`)
    );

-- --------------------------------------------------------

--
-- Table structure for table `extra_types`
--

CREATE TABLE IF NOT EXISTS `extra_types` (
    `id` int NOT NULL AUTO_INCREMENT,
    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    `name` varchar(250) DEFAULT NULL,
    PRIMARY KEY (`id`)
    );

-- --------------------------------------------------------

--
-- Table structure for table `orders`
--

CREATE TABLE IF NOT EXISTS `orders` (
    `id` int NOT NULL AUTO_INCREMENT,
    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    `customer_id` int NOT NULL,
    `status` smallint NOT NULL,
    PRIMARY KEY (`id`),
    FOREIGN KEY(`customer_id`) REFERENCES `customer`(`id`)
    );

-- --------------------------------------------------------

--
-- Table structure for table `order_items`
--

CREATE TABLE IF NOT EXISTS `order_items` (
    `id` int NOT NULL AUTO_INCREMENT,
    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    `order_product` varchar(1000) DEFAULT NULL,
    `order_id` int NOT NULL,
    PRIMARY KEY (`id`),
    FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`)
    );

-- --------------------------------------------------------

--
-- Table structure for table `product`
--

CREATE TABLE IF NOT EXISTS `product` (
    `id` int NOT NULL AUTO_INCREMENT,
    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    `name` varchar(250) NOT NULL,
    PRIMARY KEY (`id`)
    );

-- --------------------------------------------------------

--
-- Table structure for table `sugar_types`
--

CREATE TABLE IF NOT EXISTS `sugar_types` (
    `id` int NOT NULL AUTO_INCREMENT,
    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    `name` varchar(250) DEFAULT NULL,
    PRIMARY KEY (`id`)
    );
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_2__Add_Products.sql ---
SET @name = N'Espresso';

INSERT INTO product(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM product WHERE NAME = @name) = 0;

SET @name = N'Latte';

INSERT INTO product(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM product WHERE NAME = @name) = 0;

SET @name = N'Cappuccino';

INSERT INTO product(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM product WHERE NAME = @name) = 0;

SET @name = N'Americano';

INSERT INTO product(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM product WHERE NAME = @name) = 0;

SET @name = N'Mocha';

INSERT INTO product(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM product WHERE NAME = @name) = 0;

SET @name = N'Flat White';

INSERT INTO product(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM product WHERE NAME = @name) = 0;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_0__Add_SugarTypes.sql ---
SET @name = N'No Sugar (Χωρίς Ζάχαρη)';

INSERT INTO SUGAR_TYPES(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM SUGAR_TYPES WHERE NAME = @name) = 0;

SET @name = N'Minimum Sugar (Ολίγη)';

INSERT INTO SUGAR_TYPES(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM SUGAR_TYPES WHERE NAME = @name) = 0;

SET @name = N'Medium Sugar (Μέτριος)';

INSERT INTO SUGAR_TYPES(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM SUGAR_TYPES WHERE NAME = @name) = 0;

SET @name = N'Sweet (Γλυκός)';

INSERT INTO SUGAR_TYPES(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM SUGAR_TYPES WHERE NAME = @name) = 0;

SET @name = N'Extra Sweet (Πολύ Γλυκός)';

INSERT INTO SUGAR_TYPES(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM SUGAR_TYPES WHERE NAME = @name) = 0;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_1__Add_ExtraTypes.sql ---
SET @name = N'White';

INSERT INTO extra_types(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM extra_types WHERE NAME = @name) = 0;

SET @name = N'Brown';

INSERT INTO extra_types(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM extra_types WHERE NAME = @name) = 0;

SET @name = N'Stevia';

INSERT INTO extra_types(created_by, created_on, name)
SELECT 'root', CURRENT_TIMESTAMP(), @name
    WHERE (SELECT COUNT(*) FROM extra_types WHERE NAME = @name) = 0;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_6__Add_Contacts.sql ---
CREATE TABLE IF NOT EXISTS `contacts` (
    `id` int NOT NULL AUTO_INCREMENT,
    `global_id` varchar(250) NOT NULL,

    `email` varchar(250) NULL,
    `mobile` varchar(250) NULL,
    `phone` varchar(250) NULL,

    `full_name` varchar(350) NOT NULL,

    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE(`global_id`)
);

CREATE TABLE IF NOT EXISTS `subscription_schemes` (
    `id` int NOT NULL AUTO_INCREMENT,

    `contact_id` int NOT NULL,
    `channel_type` INT NOT NULL,
    `Opt` INT NOT NULL,

    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,

    PRIMARY KEY (`id`),
    UNIQUE(`contact_id`, `channel_type`),
    FOREIGN KEY(`contact_id`) REFERENCES `contacts`(`id`)
);


SET @name = N'EmailSubscription';
SET @subject = N'Subscribe';
SEt @body = N'Dear {{name}}, to subscribe to our newsletter visit http://localhost:5015/newsletter/subscribe?token={{token}}';

INSERT INTO email_template(created_by, created_on, subject, body, name)
SELECT 'root', CURRENT_TIMESTAMP(), @subject, @body, @name
    WHERE (SELECT COUNT(*) FROM email_template WHERE NAME = @name) = 0;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_5__Add_Users.sql ---
CREATE TABLE IF NOT EXISTS `users` (
    `id` int NOT NULL AUTO_INCREMENT,

    `username` VARCHAR(250) NOT NULL,
    `password` VARCHAR(250) NOT NULL,
    `expired` bit DEFAULT NOT NULL,
    `locked` bit DEFAULT NOT NULL,
    `enabled` bit DEFAULT NOT NULL,

    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,

    `reset_password_hash` varchar(50) NULL,
    PRIMARY KEY (`id`),
    UNIQUE(`username`)
);

CREATE INDEX IF NOT EXISTS UX_username ON users(username);

SET @username = N'root';
SET @password = N'$2a$10$k9EN4lt8ycukX7Hri21Alu7VuT/ezaMRKMc39NytI7kttk9vTuVDq';

INSERT INTO users(username, password, expired, locked, enabled, created_by, created_on, edited_by, edited_on, reset_password_hash)
SELECT @username, @password, FALSE, FALSE, FALSE, 'root', CURRENT_TIMESTAMP(), NULL, NULL, NULL
    WHERE (SELECT COUNT(*) FROM users WHERE username = @username) = 0;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/resources/db/migration/h2/V1_1_3__Add_EmailTemplates.sql ---
CREATE TABLE IF NOT EXISTS `email_template` (
    `id` int NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(50) NOT NULL,
    `subject` VARCHAR(250) NOT NULL,
    `body` CLOB NOT NULL,
    `created_by` varchar(250) NOT NULL,
    `created_on` datetime(6) NOT NULL,
    `edited_by` varchar(250) DEFAULT NULL,
    `edited_on` datetime(6) DEFAULT NULL,
    PRIMARY KEY (`id`)
);

SET @name = N'OrderConfirmation';
SET @subject = N'Order Confirmation {{order_id}}';
SEt @body = N'Dear {{name}} {{surname}}, thanks for your order. Id: {{order_id}}';

INSERT INTO email_template(created_by, created_on, subject, body, name)
SELECT 'root', CURRENT_TIMESTAMP(), @subject, @body, @name
    WHERE (SELECT COUNT(*) FROM email_template WHERE NAME = @name) = 0;
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/EmailTemplateService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.EmailTemplateModel;

import java.util.Optional;

public interface EmailTemplateService {
    Optional<EmailTemplateModel> getEmailTemplate(String name);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ContactNotFoundException.java ---
package com.theexperts.coffeeappbackend.business;

public class ContactNotFoundException extends Exception {
    public ContactNotFoundException() {
        super("Contact not found in backing store");
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultOrderService.java ---
package com.theexperts.coffeeappbackend.business;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.theexperts.coffeeappbackend.business.dataobjects.*;
import com.theexperts.coffeeappbackend.mail.MailService;
import com.theexperts.coffeeappbackend.mail.SendMailContext;
import com.theexperts.coffeeappbackend.persistence.Constants;
import com.theexperts.coffeeappbackend.persistence.entities.ExtraType;
import com.theexperts.coffeeappbackend.persistence.entities.Order;
import com.theexperts.coffeeappbackend.persistence.entities.OrderItem;
import com.theexperts.coffeeappbackend.persistence.entities.OrderStatus;
import com.theexperts.coffeeappbackend.persistence.repository.*;
import com.theexperts.coffeeappbackend.templates.TemplateService;
import com.theexperts.coffeeappbackend.templates.TemplateServiceContext;
import com.theexperts.coffeeappbackend.util.StringUtils;
import jakarta.transaction.Transactional;
import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.HashMap;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

@AllArgsConstructor
@Component
public class DefaultOrderService implements OrderService {
    private static final String QUEUE_NAME = "orders";
    private static final String ORDER_CONFIRMATION = "OrderConfirmation";
    private static final Logger logger = LoggerFactory.getLogger(DefaultOrderService.class);
    private static final ObjectMapper JSON_SERIALIZER = getJsonSerializer();

    private final OrdersRepository ordersRepository;
    private final CustomerRepository customerRepository;
    private final OrderItemsRepository orderItemsRepository;
    private final SugarTypesRepository sugarTypesRepository;
    private final ExtraTypesRepository extraTypesRepository;
    private final ProductRepository productRepository;
    private final MailService mailService;
    private final TemplateService templateService;
    private final EmailTemplateService emailTemplateService;
    private final MessageBus serviceBusService;

    public PageResult<OrderModel> getOrders(OrderFilter filter) {
        var pageRequest = PageRequest.of(filter.pageNumber - 1, filter.pageSize);
        var listPageRequest = Pageable.unpaged();

        if (!StringUtils.isNullOrEmpty(filter.sortKey)) {
            var sortDirection = filter.sortDirection == SortDirection.Ascending
                    ? Sort.Direction.ASC
                    : Sort.Direction.DESC;

            pageRequest = pageRequest.withSort(Sort.by(sortDirection, filter.sortKey));
            listPageRequest = Pageable.unpaged(Sort.by(sortDirection, filter.sortKey));
        }
        //hotfix
        var status = filter.status == null
                ? null
                : OrderStatuses.convert(filter.status);
        //end hotfix
        var page = ordersRepository.findAllOrderIds(status, pageRequest);
        var result = ordersRepository.findAllWithDetails(page.toList(), listPageRequest)
                .stream()
                .map(DefaultOrderService::toOrderModel)
                .toList();

        return PageResult.create(result, page.getTotalElements());
    }

    public Optional<OrderModel> getOrder(int id) {
        var order = ordersRepository.findById(id).orElse(null);

        if (order == null) {
            return Optional.empty();
        }

        return Optional.of(toOrderModel(order));
    }

    @Override
    @Transactional
    public OrderModel createOrder(OrderCreateModel order) {
        var targetTime = LocalDateTime.now(ZoneOffset.UTC);

        var customer = customerRepository.findByEmail(order.getCustomerEmail()).orElseThrow();

        var _order = ordersRepository.save(Order.builder()
                .customer(customer)
                .status(OrderStatus.PENDING)
                .createdBy(Constants.USER_DEFAULT)
                .createdOn(targetTime)
                .orderPlacedOn(targetTime)
                .build());

        var _orderItems = order.getOrderItems()
                .stream()
                .map(x -> {
                    var product = productRepository.findById(x.getProductId()).orElseThrow();
                    var sugarType = sugarTypesRepository.findById(x.getSugarTypeId()).orElseThrow();
                    var extraTypes = extraTypesRepository.findAllById(x.getExtraTypeIds());
                    var extraTypesNames = extraTypes.stream().map(ExtraType::getName).collect(Collectors.toList());

                    var orderProduct = OrderProduct.builder()
                            .productName(product.getName())
                            .sugarType(sugarType.getName())
                            .extraTypes(extraTypesNames)
                            .build();
                    var objectProductStr = orderProductToJson(orderProduct);

                    return OrderItem.builder()
                            .order(_order)
                            .orderProduct(objectProductStr)
                            .createdBy(Constants.USER_DEFAULT)
                            .createdOn(targetTime)
                            .build();
                })
                .toList();

        orderItemsRepository.saveAll(_orderItems);
        _order.setOrderItems(_orderItems);

        try {
            sendOrderCompletionEmail(_order);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        try {
            serviceBusService.publish("Order with Id " + _order.getId() + " Created", QUEUE_NAME);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }

        return this.getOrder(_order.getId()).orElseThrow();
    }

    @Override
    @Transactional
    public void updateOrderStatus(int id, OrderModelStatus status) throws OrderNotFoundException {
        Objects.requireNonNull(status);

        var order = ordersRepository.findById(id).orElse(null);

        if (order == null) {
            throw new OrderNotFoundException();
        }

        order.setStatus(OrderStatuses.convert(status));
        order.setEditedBy(Constants.USER_DEFAULT);
        order.setEditedOn(LocalDateTime.now(ZoneOffset.UTC));

        ordersRepository.save(order);

        try {
            serviceBusService.publish("Order with Id " + order.getId() + " Updated", QUEUE_NAME);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
    }

    public long countOrders() {
        return this.ordersRepository.countOrders();
    }

    private static OrderModel toOrderModel(Order order) {
        var mapper = new CustomerMapper();
        var orderItems = order.getOrderItems();

        return OrderModel.builder()
                .id(order.getId())
                .status(OrderStatuses.convert(order.getStatus()))
                .customer(mapper.map(order.getCustomer()))
                .orderItems(orderItems.stream().map(DefaultOrderService::toOrderItemModel).toList())
                .build();
    }

    private static OrderItemModel toOrderItemModel(OrderItem orderItem) {
        try {
            var orderProduct = JSON_SERIALIZER.readValue(orderItem.getOrderProduct(), OrderProduct.class);

            return OrderItemModel.builder()
                    .productName(orderProduct.getProductName())
                    .sugarType(orderProduct.getSugarType())
                    .extraTypes(orderProduct.getExtraTypes())
                    .build();
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    private static String orderProductToJson(OrderProduct orderProduct) {
        try {
            return JSON_SERIALIZER.writeValueAsString(orderProduct);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    private boolean sendOrderCompletionEmail(Order order) throws IOException {
        var customer = order.getCustomer();
        var _orderItems = order.getOrderItems();

        var orderProduct = jsonToOrderProduct(_orderItems.getFirst().getOrderProduct());

        var model = new HashMap<String, String>();

        model.put("order_id", String.valueOf(order.getId()));
        model.put("name", customer.getFullName());
        model.put("email", customer.getEmail());
        model.put("product", orderProduct.getProductName());
        model.put("sugarType", orderProduct.getSugarType());
        model.put("extraTypes", String.join(", ", orderProduct.getExtraTypes()));

        var emailTemplate = emailTemplateService.getEmailTemplate(ORDER_CONFIRMATION).orElseThrow();

        var subject = templateService.Render(TemplateServiceContext.builder()
                .template(emailTemplate.getSubject())
                .model(model)
                .build());

        var body = templateService.Render(TemplateServiceContext.builder()
                .template(emailTemplate.getBody())
                .model(model)
                .build());

        return mailService.send(SendMailContext.builder()
                .toEmail(customer.getEmail())
                .subject(subject)
                .body(body)
                .build());
    }

    private static OrderProduct jsonToOrderProduct(String json) {
        try {
            return JSON_SERIALIZER.readValue(json, OrderProduct.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    private static ObjectMapper getJsonSerializer() {
        var result = new ObjectMapper();

        result.registerModule(new JavaTimeModule());

        return result;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/RabbitMQServiceBus.java ---
package com.theexperts.coffeeappbackend.business;

import com.rabbitmq.client.ConnectionFactory;
import com.theexperts.coffeeappbackend.util.StringUtils;

import java.io.IOException;
import java.net.URISyntaxException;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeoutException;

public class RabbitMQServiceBus implements MessageBus {
    private final String connectionString;

    public RabbitMQServiceBus(String connectionString) {
        if (StringUtils.isNullOrEmpty(connectionString)) {
            throw new RuntimeException("Service bus connection string is not set");
        }

        this.connectionString = connectionString;
    }

    @Override
    public void publish(String message, String queueName) {
        var factory = new ConnectionFactory();

        try {
            factory.setUri(connectionString);
        } catch (URISyntaxException | NoSuchAlgorithmException | KeyManagementException e) {
            throw new RuntimeException(e);
        }

        try (var connection = factory.newConnection();
             var channel = connection.createChannel()) {

            channel.queueDeclare(queueName, false, false, false, null);

            channel.basicPublish("", queueName, null, message.getBytes());
        } catch (IOException | TimeoutException e) {
            throw new RuntimeException(e);
        }
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/MessageBus.java ---
package com.theexperts.coffeeappbackend.business;

public interface MessageBus {
    void publish(String messagem, String queueName);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultCustomerService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.CustomerCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.CustomerModel;
import com.theexperts.coffeeappbackend.persistence.Constants;
import com.theexperts.coffeeappbackend.persistence.entities.Customer;
import com.theexperts.coffeeappbackend.persistence.repository.CustomerRepository;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Optional;

@Component
@AllArgsConstructor
public class DefaultCustomerService implements CustomerService {
    private final CustomerRepository customerRepository;

    @Override
    public Optional<CustomerModel> getCustomer(int id) {
        var entity = customerRepository.findById(id).orElse(null);

        if (entity == null) {
            return Optional.empty();
        }

        return Optional.of(toCustomerModel(entity));
    }

    @Override
    public Optional<CustomerModel> getCustomer(String email) {
        var entity = customerRepository.findByEmail(email).orElse(null);

        if (entity == null) {
            return Optional.empty();
        }

        return Optional.of(toCustomerModel(entity));
    }

    @Override
    public CustomerModel createCustomer(CustomerCreateModel model) {
        var entity = Customer.builder()
                .email(model.getEmail())
                .createdBy(Constants.USER_DEFAULT)
                .createdOn(LocalDateTime.now(ZoneOffset.UTC))

                .fullName(model.getFullName())
                .build();

        entity = customerRepository.save(entity);

        return getCustomer(entity.getId()).orElseThrow();
    }

    public CustomerModel updateCustomer(CustomerModel customer) throws CustomerNotFoundException {
        var entity = customerRepository.findByEmail(customer.getEmail()).orElse(null);

        if (entity == null) {
            throw new CustomerNotFoundException();
        }

        entity.setEmail(customer.getEmail());
        entity.setFullName(customer.getFullName());

        customerRepository.save(entity);

        return getCustomer(entity.getId()).orElseThrow();
    }

    private static CustomerModel toCustomerModel(Customer customer) {
        var mapper = new CustomerMapper();

        return mapper.map(customer);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultProductService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ProductModel;
import com.theexperts.coffeeappbackend.persistence.entities.Product;
import com.theexperts.coffeeappbackend.persistence.repository.ProductRepository;
import lombok.AllArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@AllArgsConstructor
@Component
class DefaultProductService implements ProductService {
    private final ProductRepository productRepository;

    @Override
    public List<ProductModel> getProducts(ProductFilter filter) {
        return productRepository
                .findAll(PageRequest.of(filter.pageNumber - 1, filter.pageSize))
                .stream()
                .map(DefaultProductService::toProductModel)
                .toList();
    }

    public Optional<ProductModel> getProduct(int id) {
        var product = productRepository
                .findById(id)
                .orElse(null);

        if (product == null) {
            return Optional.empty();
        }

        return Optional.of(ProductModel.builder()
                .id(product.getId())
                .name(product.getName())
                .build());
    }

    static ProductModel toProductModel(Product product) {
        return ProductModel.builder()
                .id(product.getId())
                .name(product.getName())
                .build();
    }
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/OrderModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
public class OrderModel implements Serializable {
    private int id;
    private OrderModelStatus status;
    private CustomerModel customer;
    private List<OrderItemModel> orderItems;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/ExtraTypeModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ExtraTypeModel {
    private int id;
    private String name;
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/OrderModelStatus.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

public enum OrderModelStatus {
    PENDING,
    PROCESSING,
    AWAITING_PICKUP,
    COMPLETED,
    CANCELED
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/OrderItemCreateModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
public class OrderItemCreateModel implements Serializable {
    private Integer productId;
    private Integer sugarTypeId;
    private List<Integer> extraTypeIds;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/ContactModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

@Data
@Builder
public class ContactModel implements Serializable {
    private String globalId;
    private String email;
    private String mobile;
    private String phone;

    private String fullName;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/OrderItemModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
public class OrderItemModel implements Serializable {
    private String productName;
    private String sugarType;
    private List<String> extraTypes;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/OrderProduct.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderProduct  implements Serializable {
    private String productName;
    private String sugarType;
    private List<String> extraTypes;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/PageResult.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.io.Serializable;
import java.util.List;

@Data
@AllArgsConstructor(access = AccessLevel.PROTECTED)
public class PageResult<T extends Serializable> implements Serializable {
    private Long count;
    private List<T> items;

    public static <T extends Serializable> PageResult<T> create(List<T> items, Long count) {
        return new PageResult<>(count, items);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/EmailTemplateModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class EmailTemplateModel {
    private int id;
    private String name;
    private String subject;
    private String body;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/CustomerCreateModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

@Data
@Builder
public class CustomerCreateModel implements Serializable {
    private String email;
    private String fullName;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/UserCreateModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

@Data
@Builder
public class UserCreateModel implements Serializable {
    private String username;
    private String password;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/UserModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

@Data
@Builder
public class UserModel implements Serializable {
    private Integer id;
    private String username;
    private String password;
    private Boolean expired;
    private Boolean locked;
    private Boolean enabled;
    private String resetToken;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/CustomerModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

@Data
@Builder
public class CustomerModel implements Serializable {
    private String email;
    private String fullName;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/ContactCreateModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;

@Data
@Builder
public class ContactCreateModel implements Serializable {
    private String email;
    private String mobile;
    private String phone;

    private String fullName;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/SugarTypeModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class SugarTypeModel {
    private int id;
    private String name;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/OrderCreateModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
public class OrderCreateModel implements Serializable {
    private String customerEmail;
    private List<OrderItemCreateModel> orderItems;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/dataobjects/ProductModel.java ---
package com.theexperts.coffeeappbackend.business.dataobjects;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ProductModel {
    private int id;
    private String name;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/CustomerMapper.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.CustomerModel;
import com.theexperts.coffeeappbackend.persistence.entities.Customer;
import lombok.NoArgsConstructor;

@NoArgsConstructor
class CustomerMapper {
    public CustomerModel map(Customer customer) {
        return CustomerModel.builder()
                .email(customer.getEmail())

                // contact
                .fullName(customer.getFullName())
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/contactresolution/ContactResolver.java ---
package com.theexperts.coffeeappbackend.business.contactresolution;

import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;

import java.util.Optional;

public interface ContactResolver {
    Optional<ContactModel> resolve(ContactResolveContext context);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/contactresolution/DefaultContactResolver.java ---
package com.theexperts.coffeeappbackend.business.contactresolution;

import com.theexperts.coffeeappbackend.business.ContactService;
import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;
import com.theexperts.coffeeappbackend.util.StringUtils;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;
import java.util.stream.Stream;

@Component
@AllArgsConstructor
class DefaultContactResolver implements ContactResolver {
    ContactService contactService;

    @Override
    public Optional<ContactModel> resolve(ContactResolveContext context) {
        return Stream.of(context.getEmail(), context.getMobile(), context.getPhone())
                .filter(x -> !StringUtils.isNullOrEmpty(x))
                .map(String::trim)
                .filter(x -> !StringUtils.isNullOrEmpty(x))
                .map(x -> contactService.getContact(x))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .findFirst();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/contactresolution/ContactResolveContext.java ---
package com.theexperts.coffeeappbackend.business.contactresolution;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public final class ContactResolveContext {
    String email;
    String mobile;
    String phone;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/SugarTypeFilter.java ---
package com.theexperts.coffeeappbackend.business;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class SugarTypeFilter {
    Integer pageSize;

    Integer pageNumber;
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/AzureServiceBus.java ---
package com.theexperts.coffeeappbackend.business;

import com.azure.messaging.servicebus.ServiceBusClientBuilder;
import com.azure.messaging.servicebus.ServiceBusMessage;
import com.azure.messaging.servicebus.ServiceBusSenderClient;
import com.theexperts.coffeeappbackend.util.StringUtils;

public class AzureServiceBus implements MessageBus {
    private final String connectionString;

    public AzureServiceBus(String connectionString) {
        if (StringUtils.isNullOrEmpty(connectionString)) {
            throw new RuntimeException("Service bus connection string is not set");
        }

        this.connectionString = connectionString;
    }

    @Override
    public void publish(String message, String queueName) {
        try (var senderClient = createSenderClient(connectionString, queueName)) {
            senderClient.sendMessage(new ServiceBusMessage(message));
        }
    }

    private static ServiceBusSenderClient createSenderClient(String connectionString, String queueName) {
        return new ServiceBusClientBuilder()
                .connectionString(connectionString)
                .sender()
                .queueName(queueName)
                .buildClient();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/SortDirection.java ---
package com.theexperts.coffeeappbackend.business;

import java.util.Optional;

public class SortDirection {
    private final String direction;

    public static final SortDirection Ascending = new SortDirection("asc");
    public static final SortDirection Descending = new SortDirection("desc");

    private SortDirection(String direction) {
        this.direction = direction;
    }

    public static SortDirection parse(String sortDirection) {
        if (SortDirection.Ascending.toString().equalsIgnoreCase(sortDirection)) {
            return SortDirection.Ascending;
        }

        if (SortDirection.Descending.toString().equalsIgnoreCase(sortDirection)) {
            return SortDirection.Descending;
        }

        throw new IllegalArgumentException(String.format("cannot parse %s", sortDirection));
    }


    public static Optional<SortDirection> tryParse(String sortDirection) {
        if (SortDirection.Ascending.toString().equalsIgnoreCase(sortDirection)) {
            return Optional.of(SortDirection.Ascending);
        }

        if (SortDirection.Descending.toString().equalsIgnoreCase(sortDirection)) {
            return Optional.of(SortDirection.Descending);
        }

        return Optional.empty();
    }

    @Override
    public String toString() {
        return this.direction;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ContactMapper.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;
import com.theexperts.coffeeappbackend.persistence.entities.Contact;
import lombok.NoArgsConstructor;

@NoArgsConstructor
class ContactMapper {
    public ContactModel map(Contact contact) {
        return ContactModel.builder()
                .globalId(contact.getGlobalId())
                .email(contact.getEmail())
                .mobile(contact.getMobile())
                .phone(contact.getPhone())

                // contact
                .fullName(contact.getFullName())
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultNewsletterService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;
import com.theexperts.coffeeappbackend.mail.MailService;
import com.theexperts.coffeeappbackend.mail.SendMailContext;
import com.theexperts.coffeeappbackend.persistence.Constants;
import com.theexperts.coffeeappbackend.persistence.entities.ChannelType;
import com.theexperts.coffeeappbackend.persistence.entities.OptInOut;
import com.theexperts.coffeeappbackend.persistence.entities.SubscriptionScheme;
import com.theexperts.coffeeappbackend.persistence.repository.ContactRepository;
import com.theexperts.coffeeappbackend.persistence.repository.SubscriptionSchemeRepository;
import com.theexperts.coffeeappbackend.templates.TemplateService;
import com.theexperts.coffeeappbackend.templates.TemplateServiceContext;
import com.theexperts.coffeeappbackend.util.JwtService;
import com.theexperts.coffeeappbackend.util.StringUtils;
import com.theexperts.coffeeappbackend.util.TokenParseException;
import lombok.AllArgsConstructor;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Date;
import java.util.HashMap;

@AllArgsConstructor
@Component
class DefaultNewsletterService implements NewsletterService {
    private static final String EMAIL_SUBSCRIPTION = "EmailSubscription";
    private static final String FRONTED_URL = "frontend.url";

    private final JwtService jwt;
    private final ContactService contactService;

    private final MailService mailService;
    private final TemplateService templateService;
    private final EmailTemplateService emailTemplateService;

    private final ContactRepository contactRepository;
    private final SubscriptionSchemeRepository subscriptionSchemeRepository;
    private final Environment environment;


    @Override
    public void subscribe(ContactModel contact) throws ContactNotFoundException {
        this.subscribe(contact, false);
    }

    @Override
    public void subscribe(ContactModel contact, boolean ignoreDoubleOptIn) throws ContactNotFoundException {
        if (ignoreDoubleOptIn) {
            setOpt(contact, ChannelType.EMAIL, OptInOut.IN);

            return;
        }

        var _contact = contactRepository.findByGlobalId(contact.getGlobalId()).orElse(null);

        if (_contact == null) {
            throw new ContactNotFoundException();
        }

        var issuedAt = Instant.now();
        var expiresAt = LocalDateTime.ofInstant(issuedAt, ZoneOffset.ofHours(0))
                .plusMinutes(10)
                .atZone(ZoneOffset.ofHours(0))
                .toInstant();

        var claims = jwt.claimsBuilder()
                .subject(contact.getGlobalId())
                .issuedAt(Date.from(issuedAt))
                .expiration(Date.from(expiresAt))
                .add("scope", "self newsletter/subscribe")
                .build();

        var token = jwt.generateToken(claims, NewsletterService.class.getCanonicalName());

        try {
            sendSubscriptionEmail(contact, token);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void subscribe(String token) throws ContactNotFoundException, TokenParseException {
        var claims = jwt.parseToken(token, NewsletterService.class.getCanonicalName());

        var contact = contactService.getContact(claims.getSubject()).orElse(null);

        if (contact == null) {
            throw new ContactNotFoundException();
        }

        setOpt(contact, ChannelType.EMAIL, OptInOut.IN);
    }

    @Override
    public void unsubscribe(ContactModel contact) throws ContactNotFoundException {
        setOpt(contact, ChannelType.EMAIL, OptInOut.OUT);
    }

    @Override
    public void unsubscribe(String token) throws ContactNotFoundException, TokenParseException {
        var claims = jwt.parseToken(token, NewsletterService.class.getCanonicalName());

        var contact = contactService.getContact(claims.getSubject()).orElse(null);

        if (contact == null) {
            throw new ContactNotFoundException();
        }

        this.unsubscribe(contact);
    }

    private void setOpt(ContactModel contact, ChannelType channelType, OptInOut opt) throws ContactNotFoundException {
        var _contact = contactRepository.findByGlobalId(contact.getGlobalId()).orElse(null);

        if (_contact == null) {
            throw new ContactNotFoundException();
        }

        var subscriptionScheme = subscriptionSchemeRepository.findByContact(contact.getGlobalId())
                .stream()
                .filter(x -> x.getChannelType().equals(channelType))
                .findFirst()
                .orElse(null);

        if (subscriptionScheme != null && subscriptionScheme.getOpt() == opt) {
            return;
        }

        if (subscriptionScheme == null) {
            subscriptionScheme = SubscriptionScheme.builder()
                    .channelType(ChannelType.EMAIL)
                    .contact(_contact)

                    .createdBy(Constants.USER_DEFAULT)
                    .createdOn(LocalDateTime.now(ZoneOffset.UTC))
                    .build();
        }

        subscriptionScheme.setOpt(opt);

        subscriptionSchemeRepository.save(subscriptionScheme);
    }

    private boolean sendSubscriptionEmail(ContactModel contact, String token) throws IOException {
        var frontendUrl = environment.containsProperty(FRONTED_URL) && !StringUtils.isNullOrEmpty(environment.getProperty(FRONTED_URL))
                ? environment.getProperty(FRONTED_URL)
                : "";

        var model = new HashMap<String, String>();

        model.put("name", contact.getFullName());
        model.put("email", contact.getEmail());
        model.put("confirmation_link", frontendUrl + "/newsletter/subscribe?token=" + token);

        var emailTemplate = emailTemplateService.getEmailTemplate(EMAIL_SUBSCRIPTION).orElse(null);

        if (emailTemplate == null) {
            throw new RuntimeException("Email template not found");
        }

        var subject = templateService.Render(TemplateServiceContext.builder()
                .template(emailTemplate.getSubject())
                .model(model)
                .build());

        var body = templateService.Render(TemplateServiceContext.builder()
                .template(emailTemplate.getBody())
                .model(model)
                .build());

        return mailService.send(SendMailContext.builder()
                .toEmail(contact.getEmail())
                .subject(subject)
                .body(body)
                .build());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/OrderNotFoundException.java ---
package com.theexperts.coffeeappbackend.business;

public class OrderNotFoundException extends Exception {
    public OrderNotFoundException() {
        super("Order not found in backing store");
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultExtraTypeService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ExtraTypeModel;
import com.theexperts.coffeeappbackend.persistence.entities.ExtraType;
import com.theexperts.coffeeappbackend.persistence.repository.ExtraTypesRepository;
import lombok.AllArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@AllArgsConstructor
@Component
class DefaultExtraTypeService implements ExtraTypeService {
    final ExtraTypesRepository extraTypeRepository;

    @Override
    public List<ExtraTypeModel> getExtraTypes(ExtraTypeFilter filter) {
        return extraTypeRepository
                .findAll(PageRequest.of(filter.pageNumber - 1, filter.pageSize))
                .stream()
                .map(DefaultExtraTypeService::toExtraTypeModel)
                .toList();
    }

    public Optional<ExtraTypeModel> getExtraType(int id) {
        var extraType = extraTypeRepository
                .findById(id)
                .orElse(null);

        if (extraType == null) {
            return Optional.empty();
        }

        return Optional.of(toExtraTypeModel(extraType));
    }

    static ExtraTypeModel toExtraTypeModel(ExtraType extraType) {
        return ExtraTypeModel.builder()
                .id(extraType.getId())
                .name(extraType.getName())
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/OrderStatuses.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.OrderModelStatus;
import com.theexperts.coffeeappbackend.persistence.entities.OrderStatus;

import java.util.Objects;

final class OrderStatuses {
    private OrderStatuses() {
    }
    
    static OrderStatus convert(OrderModelStatus status) {
        Objects.requireNonNull(status);

        return switch (status) {
            case PENDING -> OrderStatus.PENDING;
            case PROCESSING -> OrderStatus.PROCESSING;
            case AWAITING_PICKUP -> OrderStatus.AWAITING_PICKUP;
            case COMPLETED -> OrderStatus.COMPLETED;
            case CANCELED -> OrderStatus.CANCELED;
        };
    }

    static OrderModelStatus convert(OrderStatus status) {
        Objects.requireNonNull(status);

        return switch (status) {
            case PENDING -> OrderModelStatus.PENDING;
            case PROCESSING -> OrderModelStatus.PROCESSING;
            case AWAITING_PICKUP -> OrderModelStatus.AWAITING_PICKUP;
            case COMPLETED -> OrderModelStatus.COMPLETED;
            case CANCELED -> OrderModelStatus.CANCELED;
        };
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/UserMapper.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.UserModel;
import com.theexperts.coffeeappbackend.persistence.entities.User;
import lombok.NoArgsConstructor;

@NoArgsConstructor
class UserMapper {
    public UserModel map(User user) {
        return UserModel.builder()
                .id(user.getId())

                .username(user.getUsername())
                .password(user.getPassword())
                .expired(user.getExpired())
                .locked(user.getLocked())
                .enabled(user.getEnabled())

                .resetToken(user.getResetPasswordHash())
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/CustomerService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.CustomerCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.CustomerModel;

import java.util.Optional;

public interface CustomerService {
    Optional<CustomerModel> getCustomer(int id);

    Optional<CustomerModel> getCustomer(String email);

    CustomerModel createCustomer(CustomerCreateModel customer);

    CustomerModel updateCustomer(CustomerModel customer) throws CustomerNotFoundException;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/CustomerNotFoundException.java ---
package com.theexperts.coffeeappbackend.business;

public class CustomerNotFoundException extends Exception {
    public CustomerNotFoundException() {
        super("Customer not found in backing store");
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/OrderService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.OrderCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.OrderModel;
import com.theexperts.coffeeappbackend.business.dataobjects.OrderModelStatus;
import com.theexperts.coffeeappbackend.business.dataobjects.PageResult;

import java.util.Optional;

public interface OrderService {
    PageResult<OrderModel> getOrders(OrderFilter filter);

    Optional<OrderModel> getOrder(int id);

    OrderModel createOrder(OrderCreateModel order);

    void updateOrderStatus(int id, OrderModelStatus status) throws OrderNotFoundException;

    long countOrders();
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/OrderFilter.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.OrderModelStatus;
import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class OrderFilter {
    OrderModelStatus status;

    Integer pageSize;

    Integer pageNumber;

    SortDirection sortDirection;

    String sortKey;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultEmailTemplateService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.EmailTemplateModel;
import com.theexperts.coffeeappbackend.persistence.entities.EmailTemplate;
import com.theexperts.coffeeappbackend.persistence.repository.EmailTemplateRepository;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Optional;

@AllArgsConstructor
@Component
public class DefaultEmailTemplateService implements EmailTemplateService {
    private final EmailTemplateRepository emailTemplateRepository;

    @Override
    public Optional<EmailTemplateModel> getEmailTemplate(String name) {
        var emailTemplate = emailTemplateRepository
                .findByName(name)
                .orElse(null);

        if (emailTemplate == null) {
            return Optional.empty();
        }

        return Optional.of(toEmailTemplateModel(emailTemplate));
    }

    static EmailTemplateModel toEmailTemplateModel(EmailTemplate emailTemplate) {
        return EmailTemplateModel.builder()
                .id(emailTemplate.getId())
                .name(emailTemplate.getName())
                .subject(emailTemplate.getSubject())
                .body(emailTemplate.getBody())
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/NewsletterService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;
import com.theexperts.coffeeappbackend.util.TokenParseException;

public interface NewsletterService {
    void subscribe(ContactModel contact) throws ContactNotFoundException;

    void subscribe(ContactModel contact, boolean ignoreDoubleOptIn) throws ContactNotFoundException;

    void subscribe(String token) throws ContactNotFoundException, TokenParseException;

    void unsubscribe(ContactModel contact) throws ContactNotFoundException;

    void unsubscribe(String token) throws ContactNotFoundException, TokenParseException;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultContactService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ContactCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;
import com.theexperts.coffeeappbackend.persistence.Constants;
import com.theexperts.coffeeappbackend.persistence.entities.Contact;
import com.theexperts.coffeeappbackend.persistence.repository.ContactRepository;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Optional;

@Component
@AllArgsConstructor
public class DefaultContactService implements ContactService {
    private final ContactRepository repository;

    @Override
    public Optional<ContactModel> getContact(int id) {
        return repository
                .findById(id)
                .map(DefaultContactService::toContactModel);
    }

    @Override
    public Optional<ContactModel> getContact(String globalId) {
        return repository
                .findByGlobalId(globalId)
                .map(DefaultContactService::toContactModel);
    }

    @Override
    public ContactModel createContact(ContactCreateModel model) {
        var builder = Contact.builder()
                .email(model.getEmail())
                .globalId(model.getEmail())
                .createdBy(Constants.USER_DEFAULT)
                .createdOn(LocalDateTime.now(ZoneOffset.UTC))

                .fullName(model.getFullName());

        var entity = builder.build();

        entity = repository.save(entity);

        return toContactModel(entity);
    }

    public ContactModel updateContact(ContactModel contact) throws ContactNotFoundException {
        var entity = repository
                .findByGlobalId(contact.getGlobalId())
                .orElseThrow(ContactNotFoundException::new);

        entity.setEmail(contact.getEmail());
        entity.setMobile(contact.getMobile());
        entity.setPhone(contact.getPhone());
        entity.setFullName(contact.getFullName());

        entity = repository.save(entity);

        return toContactModel(entity);
    }

    private static ContactModel toContactModel(Contact contact) {
        var mapper = new ContactMapper();

        return mapper.map(contact);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultUserService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.UserCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.UserModel;
import com.theexperts.coffeeappbackend.persistence.Constants;
import com.theexperts.coffeeappbackend.persistence.entities.User;
import com.theexperts.coffeeappbackend.persistence.repository.UserRepository;
import lombok.AllArgsConstructor;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Optional;

@Component
@AllArgsConstructor
class DefaultUserService implements UserService {
    private static final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    private final UserRepository userRepository;

    @Override
    public Optional<UserModel> getUser(int id) {
        var entity = userRepository.findById(id).orElse(null);

        if (entity == null) {
            return Optional.empty();
        }

        return Optional.of(toUserModel(entity));
    }

    public Optional<UserModel> getUser(String username) {
        var entity = userRepository.findByUsername(username).orElse(null);

        if (entity == null) {
            return Optional.empty();
        }

        return Optional.of(toUserModel(entity));
    }

    @Override
    public UserModel createUser(UserCreateModel model) {
        var builder = User.builder()
                .username(model.getUsername())
                .password(encoder.encode(model.getPassword()))
                .expired(false)
                .locked(false)
                .enabled(false)
                .createdBy(Constants.USER_DEFAULT)
                .createdOn(LocalDateTime.now(ZoneOffset.UTC));

        var entity = builder.build();

        var id = userRepository.save(entity).getId();

        return getUser(id).orElseThrow();
    }

    @Override
    public UserModel updateUser(UserModel user) throws UserNotFoundException {
        var entity = userRepository.findById(user.getId()).orElse(null);

        if (entity == null) {
            throw new UserNotFoundException();
        }

        entity.setUsername(user.getUsername());
        entity.setPassword(encoder.encode(user.getPassword()));


        entity.setExpired(user.getExpired());
        entity.setLocked(user.getLocked());
        entity.setEnabled(user.getEnabled());

        entity.setResetPasswordHash(user.getResetToken());

        var id = userRepository.save(entity).getId();

        return getUser(id).orElseThrow();
    }

    @Override
    public void deleteUser(int id) throws UserNotFoundException {
        var user = userRepository.findById(id).orElse(null);

        if (user == null) {
            throw new UserNotFoundException();
        }

        userRepository.delete(user);
    }

    private static UserModel toUserModel(User user) {
        var mapper = new UserMapper();

        return mapper.map(user);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/UserService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.UserCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.UserModel;

import java.util.Optional;

public interface UserService {
    Optional<UserModel> getUser(int id);

    Optional<UserModel> getUser(String username);

    UserModel createUser(UserCreateModel user);

    UserModel updateUser(UserModel user) throws UserNotFoundException;

    void deleteUser(int id) throws UserNotFoundException;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ExtraTypeService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ExtraTypeModel;

import java.util.List;
import java.util.Optional;

public interface ExtraTypeService {
    List<ExtraTypeModel> getExtraTypes(ExtraTypeFilter filter);

    Optional<ExtraTypeModel> getExtraType(int id);
}


--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/SugarTypeService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.SugarTypeModel;

import java.util.List;
import java.util.Optional;

public interface SugarTypeService {
    List<SugarTypeModel> getSugarTypes(SugarTypeFilter filter);

    Optional<SugarTypeModel> getSugarType(int id);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ExtraTypeFilter.java ---
package com.theexperts.coffeeappbackend.business;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ExtraTypeFilter {
    Integer pageSize;
    Integer pageNumber;
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/UserNotFoundException.java ---
package com.theexperts.coffeeappbackend.business;

public class UserNotFoundException extends Exception {
    public UserNotFoundException() {
        super("Customer not found in backing store");
    }
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ContactService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ContactCreateModel;
import com.theexperts.coffeeappbackend.business.dataobjects.ContactModel;

import java.util.Optional;

public interface ContactService {
    Optional<ContactModel> getContact(int id);

    Optional<ContactModel> getContact(String globalId);

    ContactModel createContact(ContactCreateModel contact);

    ContactModel updateContact(ContactModel contact) throws ContactNotFoundException;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ProductFilter.java ---
package com.theexperts.coffeeappbackend.business;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class ProductFilter {
    Integer pageSize;

    Integer pageNumber;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/ProductService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.ProductModel;

import java.util.List;
import java.util.Optional;

public interface ProductService {
    List<ProductModel> getProducts(ProductFilter filter);

    Optional<ProductModel> getProduct(int id);
}


--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/business/DefaultSugarTypeService.java ---
package com.theexperts.coffeeappbackend.business;

import com.theexperts.coffeeappbackend.business.dataobjects.SugarTypeModel;
import com.theexperts.coffeeappbackend.persistence.entities.SugarType;
import com.theexperts.coffeeappbackend.persistence.repository.SugarTypesRepository;
import lombok.AllArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@AllArgsConstructor
@Component
class DefaultSugarTypeService implements SugarTypeService {
    private final SugarTypesRepository sugarTypesRepository;

    @Override
    public List<SugarTypeModel> getSugarTypes(SugarTypeFilter filter) {
        return sugarTypesRepository
                .findAll(PageRequest.of(filter.pageNumber - 1, filter.pageSize))
                .stream()
                .map(DefaultSugarTypeService::toSugarTypeModel)
                .toList();
    }

    public Optional<SugarTypeModel> getSugarType(int id) {
        var sugarType = sugarTypesRepository
                .findById(id)
                .orElse(null);

        if (sugarType == null) {
            return Optional.empty();
        }

        return Optional.of(toSugarTypeModel(sugarType));
    }

    static SugarTypeModel toSugarTypeModel(SugarType sugarType) {
        return SugarTypeModel.builder()
                .id(sugarType.getId())
                .name(sugarType.getName())
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/templates/TemplateService.java ---
package com.theexperts.coffeeappbackend.templates;

import java.io.IOException;

public interface TemplateService {
    String Render(TemplateServiceContext context) throws IOException;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/templates/handlebars/HandlebarsTemplateService.java ---
package com.theexperts.coffeeappbackend.templates.handlebars;

import com.github.jknack.handlebars.Handlebars;
import com.theexperts.coffeeappbackend.templates.TemplateService;
import com.theexperts.coffeeappbackend.templates.TemplateServiceContext;

import java.io.IOException;

public class HandlebarsTemplateService implements TemplateService {
    private final Handlebars handlebars;

    public HandlebarsTemplateService() {
        this.handlebars = new Handlebars();
    }

    public String Render(TemplateServiceContext context) throws IOException {
        try {
            var template = handlebars.compileInline(context.getTemplate());

            return template.apply(context.getModel());
        } catch (Exception e) {
            throw new IOException("Failed to render template", e);
        }
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/templates/TemplateServiceContext.java ---
package com.theexperts.coffeeappbackend.templates;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class TemplateServiceContext {
    String template;
    Object model;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/UserRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Integer> {
    Optional<User> findByUsername(String username);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/EmailTemplateRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.EmailTemplate;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface EmailTemplateRepository extends JpaRepository<EmailTemplate, Integer> {
    Optional<EmailTemplate> findByName(String name);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/OrdersRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.Order;
import com.theexperts.coffeeappbackend.persistence.entities.OrderStatus;
import org.hibernate.annotations.Fetch;
import org.hibernate.annotations.FetchMode;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface OrdersRepository extends JpaRepository<Order, Integer> {
    // https://medium.com/@majbahbuet08/performance-pitfalls-while-using-spring-data-jpa-and-solutions-to-avoid-them-5eb4ee3fe4ea
    @Query(
            value = "SELECT o.id FROM Order o WHERE :status is null or o.status = :status",
            countQuery = "SELECT count(o) FROM Order o WHERE :status is null or o.status = :status"
    )
    Page<Long> findAllOrderIds(@Param("status") OrderStatus status, Pageable pageable);

    @EntityGraph(attributePaths = {"customer", "orderItems"})
    @Query("FROM Order order WHERE order.id in :orderIds")
    @Fetch(FetchMode.SUBSELECT)
    List<Order> findAllWithDetails(@Param("orderIds") List<Long> orderIds, Pageable pageable);

    @Query("SELECT COUNT(*) FROM Order order WHERE order.createdOn > CURRENT_DATE")
    Long countOrders();
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/SugarTypesRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.SugarType;
import org.springframework.data.jpa.repository.JpaRepository;

public interface SugarTypesRepository extends JpaRepository<SugarType, Integer> {
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/ExtraTypesRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.ExtraType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ExtraTypesRepository extends JpaRepository<ExtraType,Integer> {
    Page<ExtraType> findAll(Pageable pageable);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/OrderItemsRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderItemsRepository extends JpaRepository<OrderItem,Integer> {
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/ProductRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductRepository extends JpaRepository<Product, Integer> {
    Page<Product> findAll(Pageable pageable);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/SubscriptionSchemeRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.SubscriptionScheme;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface SubscriptionSchemeRepository extends JpaRepository<SubscriptionScheme, Integer> {
    @Query("SELECT s FROM SubscriptionScheme s WHERE s.contact.globalId = :globalId")
    List<SubscriptionScheme> findByContact(@Param("globalId") String globalId);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/ContactRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.Contact;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ContactRepository extends JpaRepository<Contact, Integer> {
    Optional<Contact> findByGlobalId(String globalId);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/repository/CustomerRepository.java ---
package com.theexperts.coffeeappbackend.persistence.repository;

import com.theexperts.coffeeappbackend.persistence.entities.Customer;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface CustomerRepository extends JpaRepository<Customer, Integer> {
    Optional<Customer> findByEmail(String email);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/Constants.java ---
package com.theexperts.coffeeappbackend.persistence;

public final class Constants {
    public static final String USER_DEFAULT = "root";

    private Constants() {
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/Product.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
@Entity
@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Table(name="product")
public class Product implements Serializable {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 250, message = "Name cannot be larger than 250")
    @NotNull(message = "Name cannot be null")
    @NotEmpty(message = "Name cannot be empty")
    String name;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @Size(max = 250, message = "Created By cannot be larger than 250")
    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/EmailTemplate.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@NoArgsConstructor
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "emailTemplate")
public class EmailTemplate {

    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 50, message = "Name cannot be larger than 50")
    @NotNull(message = "Name cannot be null")
    @NotEmpty(message = "Name cannot be empty")
    String name;

    @Size(max = 250, message = "Subject cannot be larger than 250")
    @NotNull(message = "Subject cannot be null")
    @NotEmpty(message = "Subject cannot be empty")
    String subject;

    @Column(columnDefinition = "NVARCHAR(MAX)")
    @NotNull(message = "Body cannot be null")
    @NotEmpty(message = "Body cannot be empty")
    String body;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/ChannelType.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

public enum ChannelType {
    EMAIL,
    SMS,
    MOBILE,
    PHONE,
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/ExtraType.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;

@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "extraTypes")
public class ExtraType implements Serializable {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 250, message = "Name cannot be larger than 250")
    String name;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/User.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.time.LocalDateTime;

@Data
@Entity
@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Table(name = "users")
public class User {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 250, message = "username cannot be larger than 250")
    @NotNull(message = "username cannot be null")
    @NotEmpty(message = "username cannot be empty")
    String username;

    @Size(max = 250, message = "password cannot be larger than 250")
    @NotNull(message = "password cannot be null")
    @NotEmpty(message = "password cannot be empty")
    String password;

    Boolean expired;

    Boolean locked;

    Boolean enabled;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @Size(max = 250, message = "Created By cannot be larger than 250")
    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;

    @Size(max = 50, message = "Reset password hash By cannot be larger than 250")
    String resetPasswordHash;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/Customer.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;

@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "customer", indexes =
@Index(name = "IX_email", columnList = "email", unique = true)
)
public class Customer implements Serializable {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 250, message = "Email cannot be larger than 250")
    @NotNull(message = "Email cannot be null")
    @NotEmpty(message = "Email cannot be empty")
    @Email
    String email;

    @Size(max = 350, message = "Full name cannot be larger than 350")
    @NotNull(message = "First name cannot be null")
    @NotEmpty(message = "First name cannot be empty")
    String fullName;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/SugarType.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
@Entity
@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Table(name="sugarTypes")
public class SugarType implements Serializable {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 250, message = "Name cannot be larger than 250")
    String name;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @Size(max = 250, message = "Created By cannot be larger than 250")
    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/SubscriptionScheme.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;

@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "subscription_schemes", indexes =
@Index(name = "IX_contact_id", columnList = "contactId", unique = true)
)
public class SubscriptionScheme implements Serializable {

    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @ManyToOne
    @JoinColumn(name = "contact_id", nullable = false)
    Contact contact;

    @Column(name = "channel_type")
    ChannelType channelType;

    OptInOut Opt;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/Contact.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;

@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "contacts", indexes =
@Index(name = "IX_email", columnList = "email", unique = true)
)
public class Contact implements Serializable {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @Size(max = 250, message = "globalId cannot be larger than 250")
    @NotNull(message = "globalId cannot be null")
    @NotEmpty(message = "globalId cannot be empty")
    private String globalId;

    @Size(max = 250, message = "Email cannot be larger than 250")
    @NotNull(message = "Email cannot be null")
    @NotEmpty(message = "Email cannot be empty")
    @Email
    String email;

    @Size(max = 250, message = "Mobile cannot be larger than 250")
    String mobile;

    @Size(max = 250, message = "Phone cannot be larger than 250")
    String phone;

    @Size(max = 350, message = "Full name cannot be larger than 350")
    @NotNull(message = "First name cannot be null")
    @NotEmpty(message = "First name cannot be empty")
    String fullName;

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/OrderStatus.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

public enum OrderStatus {
    PENDING,
    PROCESSING,
    AWAITING_PICKUP,
    COMPLETED,
    CANCELED
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/Order.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Integer id;

    @ManyToOne
    @JoinColumn(name = "customerId", nullable = false)
    Customer customer;

    @NotNull
    OrderStatus status;

    @Builder.Default
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    List<OrderItem> orderItems = new ArrayList<>();

    @NotNull(message = "Created on cannot be null")
    LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    String createdBy;

    LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    String editedBy;

    LocalDateTime orderPlacedOn;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/OptInOut.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

public enum OptInOut {
    UNSPECIFIED,
    IN,
    OUT
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/persistence/entities/OrderItem.java ---
package com.theexperts.coffeeappbackend.persistence.entities;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.time.LocalDateTime;

@Builder
@NoArgsConstructor()
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Data
@Entity
@Table(name = "orderItems")
public class OrderItem {
    @Id
    @Column(unique = true)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Integer id;

    @JsonBackReference
    @ManyToOne
    @JoinColumn(name = "orderId", nullable = false)
    public Order order;

    @NotEmpty(message = "Order Product cannot be empty")
    @Size(max = 1000, message = "Order Product cannot be larger than 1000")
    public String orderProduct;

    @NotNull(message = "Created on cannot be null")
    public LocalDateTime createdOn;

    @NotNull(message = "Created By cannot be null")
    @NotEmpty(message = "Created By cannot be empty")
    @Size(max = 250, message = "Created By cannot be larger than 250")
    public String createdBy;

    public LocalDateTime editedOn;

    @Size(max = 250, message = "Edited By cannot be larger than 250")
    public String editedBy;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/mail/sendgrid/SendgridMailServiceOptions.java ---
package com.theexperts.coffeeappbackend.mail.sendgrid;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class SendgridMailServiceOptions {
    String defaultSenderEmail;
    String apiKey;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/mail/sendgrid/SendgridMailService.java ---
package com.theexperts.coffeeappbackend.mail.sendgrid;

import com.sendgrid.Method;
import com.sendgrid.Request;
import com.sendgrid.SendGrid;
import com.sendgrid.SendGridAPI;
import com.sendgrid.helpers.mail.Mail;
import com.sendgrid.helpers.mail.objects.Content;
import com.sendgrid.helpers.mail.objects.Email;
import com.theexperts.coffeeappbackend.mail.MailService;
import com.theexperts.coffeeappbackend.mail.SendMailContext;
import com.theexperts.coffeeappbackend.util.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Objects;

public final class SendgridMailService implements MailService {
    private static final Logger logger = LoggerFactory.getLogger(SendgridMailService.class);
    private static final String ERROR_LOG = """
            Failed to send email
            Status Code: {}
            Subject: {}
            To: {}
            From: {}
            Body: {}
            """;

    private final SendgridMailServiceOptions options;
    private final SendGridAPI sendGridAPI;

    public SendgridMailService(SendgridMailServiceOptions options) {
        Objects.requireNonNull(options, "options must not be null");

        this.options = options;
        this.sendGridAPI = new SendGrid(options.apiKey);
    }

    @Override
    public Boolean send(SendMailContext context) throws IOException {
        Objects.requireNonNull(context, "context must not be null");

        if (StringUtils.isNullOrEmpty(context.getToEmail())) {
            logger.error("To email is required");

            return false;
        }

        var content = new Content(context.getType(), context.getBody());

        var fromEmail = !StringUtils.isNullOrEmpty(context.getFromEmail())
                ? context.getFromEmail()
                : options.defaultSenderEmail;

        var mail = new Mail(
                new Email(fromEmail),
                context.getSubject(),
                new Email(context.getToEmail()),
                content);

        var request = new Request();
        request.setMethod(Method.POST);
        request.setEndpoint("mail/send");
        request.setBody(mail.build());
        var response = sendGridAPI.api(request);

        var success = response.getStatusCode() >= 200 && response.getStatusCode() < 300;

        if (!success) {
            logger.info(ERROR_LOG, response.getStatusCode(), context.getSubject(), context.getToEmail(), fromEmail, context.getBody());
        }

        return success;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/mail/ConsoleMailService.java ---
package com.theexperts.coffeeappbackend.mail;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A mail service that logs the email to the console.
 */
public class ConsoleMailService implements MailService {
    private static final Logger logger = LoggerFactory.getLogger(ConsoleMailService.class);
    private static final String ERROR_LOG = """
            Failed to send email
            Subject: {}
            To: {}
            Body: {}
            """;

    @Override
    public Boolean send(SendMailContext context) {
        logger.info(ERROR_LOG, context.getSubject(), context.getToEmail(), context.getBody());

        return true;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/mail/SendMailContext.java ---
package com.theexperts.coffeeappbackend.mail;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class SendMailContext
{
    private String fromEmail;
    private String toEmail;
    private String subject;
    private String body;
    @Builder.Default
    private String type = "text/html";
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/mail/MailService.java ---
package com.theexperts.coffeeappbackend.mail;

import java.io.IOException;

public interface MailService {
    Boolean send(SendMailContext context) throws IOException;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/Application.java ---
package com.theexperts.coffeeappbackend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/GlobalExceptionHandler.java ---
package com.theexperts.coffeeappbackend.web;

import com.theexperts.coffeeappbackend.web.responses.ErrorResponse;
import com.theexperts.coffeeappbackend.web.responses.GenericErrorResponse;
import com.theexperts.coffeeappbackend.web.responses.ValidationError;
import com.theexperts.coffeeappbackend.web.responses.ValidationErrorResponse;
import jakarta.validation.ConstraintViolationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.time.ZoneOffset;

@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Object> handle(MethodArgumentNotValidException e) {
        var errors = e.getBindingResult().getFieldErrors()
                .stream()
                .map(x -> ValidationError.builder()
                        .path(x.getField())
                        .message(x.getDefaultMessage())
                        .build())
                .toList();

        var data = ValidationErrorResponse.builder()
                .timestamp(LocalDateTime.now(ZoneOffset.UTC))
                .status(HttpStatus.BAD_REQUEST)
                .message(e.getMessage())
                .errors(errors)
                .build();

        log(e);

        return response(data);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<Object> handle(ConstraintViolationException e) {
        var errors = e.getConstraintViolations()
                .stream()
                .map(x -> ValidationError.builder()
                        .path(x.getPropertyPath().toString())
                        .message(x.getMessage())
                        .build())
                .toList();

        var data = ValidationErrorResponse.builder()
                .timestamp(LocalDateTime.now(ZoneOffset.UTC))
                .status(HttpStatus.BAD_REQUEST)
                .message(e.getMessage())
                .errors(errors)
                .build();

        log(e);

        return response(data);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<Object> handle(ValidationException e) {
        var data = ValidationErrorResponse.builder()
                .timestamp(LocalDateTime.now(ZoneOffset.UTC))
                .status(HttpStatus.BAD_REQUEST)
                .message(e.getMessage())
                .errors(e.errors)
                .build();

        log(e);

        return response(data);
    }

    @ExceptionHandler
    public ResponseEntity<Object> handle(Exception e) {
        var data = GenericErrorResponse.builder()
                .timestamp(LocalDateTime.now(ZoneOffset.UTC))
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .message(e.getMessage())
                .build();

        log(e);

        return response(data);
    }

    private static void log(Exception e) {
        logger.error(e.getMessage(), e);
    }

    private static ResponseEntity<Object> response(ErrorResponse error) {
        return new ResponseEntity<>(error, new HttpHeaders(), error.getStatus());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/ValidationException.java ---
package com.theexperts.coffeeappbackend.web;

import com.theexperts.coffeeappbackend.web.responses.ValidationError;
import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

@Getter
public class ValidationException extends RuntimeException {
    private static final String DEFAULT_MESSAGE = "Validation Error";

    protected final ArrayList<ValidationError> errors;

    public ValidationException(List<ValidationError> errors) {
        super(DEFAULT_MESSAGE);

        this.errors = new ArrayList<>(errors);
    }

    public ValidationException(List<ValidationError> errors, Throwable cause) {
        super(DEFAULT_MESSAGE, cause);

        this.errors = new ArrayList<>(errors);
    }

    public static ValidationException create(String path, String message) {
        return new ValidationException(List.of(ValidationError.create(path, message)));
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/pages/Page.java ---
package com.theexperts.coffeeappbackend.web.pages;

import java.util.Objects;

public final class Page {
    public static final String NAME = "page";
    public static final Page DEFAULT = new Page(1);

    private final Integer value;

    private Page(Integer page) {
        this.value = page;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        return o instanceof Page page && Objects.equals(value, page.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    }

    public int get() {
        return value;
    }

    public static Page of(Integer page) {
        Objects.requireNonNull(page);

        return new Page(page);
    }

    public static Page of(String page) {
        Objects.requireNonNull(page);

        return Page.of(Integer.valueOf(page));
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/pages/PagesValidator.java ---
package com.theexperts.coffeeappbackend.web.pages;

import com.theexperts.coffeeappbackend.web.ValidationException;
import com.theexperts.coffeeappbackend.web.responses.ValidationError;
import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@AllArgsConstructor
public class PagesValidator {
    private final PageValidator pageValidator;
    private final PageSizeValidator pageSizeValidator;

    public static final PagesValidator DEFAULT = getInstance();

    public void validate(Page page, PageSize pageSize, List<ValidationError> errors) {
        pageValidator.validate(page, errors);
        pageSizeValidator.validate(pageSize, errors);
    }

    public final void ensureValid(Page page, PageSize pageSize) {
        var errors = new ArrayList<ValidationError>();

        validate(page, pageSize, errors);

        if (!errors.isEmpty()) {
            throw new ValidationException(errors);
        }
    }

    private static PagesValidator getInstance() {
        return new PagesValidator((page, errors) -> {
            Objects.requireNonNull(page);

            if (page.get() <= 0) {
                errors.add(ValidationError.create("page", "cannot be less than or equal to 0"));
            }
        }, (pageSize, errors) -> {
            Objects.requireNonNull(pageSize);

            if (pageSize.get() <= 0) {
                errors.add(ValidationError.create("pageSize", "cannot be less than or equal to 0"));
            }
        });
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/pages/PageValidator.java ---
package com.theexperts.coffeeappbackend.web.pages;

import com.theexperts.coffeeappbackend.web.responses.ValidationError;

import java.util.List;

@FunctionalInterface
public interface PageValidator {
    void validate(Page page, List<ValidationError> errors);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/pages/PageSizeValidator.java ---
package com.theexperts.coffeeappbackend.web.pages;

import com.theexperts.coffeeappbackend.web.responses.ValidationError;

import java.util.List;

@FunctionalInterface
public interface PageSizeValidator {
    void validate(PageSize pageSize, List<ValidationError> errors);
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/pages/PageSize.java ---
package com.theexperts.coffeeappbackend.web.pages;

import java.util.Objects;

public final class PageSize {
    public static final String NAME = "pageSize";
    public static final PageSize DEFAULT = new PageSize(100);

    private final Integer value;

    private PageSize(Integer page) {
        this.value = page;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        return o instanceof PageSize pageSize && Objects.equals(value, pageSize.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    @Override
    public String toString() {
        return String.valueOf(value);
    }

    public int get() {
        return value;
    }

    public static PageSize of(Integer page) {
        Objects.requireNonNull(page);

        return new PageSize(page);
    }

    public static PageSize of(String page) {
        Objects.requireNonNull(page);

        return PageSize.of(Integer.valueOf(page));
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/model/RemoveSubscriptionRequest.java ---
package com.theexperts.coffeeappbackend.web.model;

import lombok.Data;

@Data
public class RemoveSubscriptionRequest {
    private String token;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/model/OrderCreateRequest.java ---
package com.theexperts.coffeeappbackend.web.model;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.util.List;

@Data
public class OrderCreateRequest {
    @NotBlank
    @Email
    private String email;

    @NotBlank
    private String fullName;

    private Boolean subscribe;

    @NotNull(message = "cannot be null")
    private Integer productId;

    @NotNull(message = "cannot be null")
    private Integer sugarTypeId;

    private List<Integer> extraTypeIds;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/model/AddSubscriptionRequest.java ---
package com.theexperts.coffeeappbackend.web.model;

import lombok.Data;

@Data
public class AddSubscriptionRequest {
    private String token;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/model/SubscriptionRequest.java ---
package com.theexperts.coffeeappbackend.web.model;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class SubscriptionRequest {
    @NotBlank(message = "Email is required")
    @Size(max = 250, message = "Email cannot be larger than 250")
    private String email;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/model/ContactCreateRequest.java ---
package com.theexperts.coffeeappbackend.web.model;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class ContactCreateRequest {
    @NotBlank(message = "Email is required")
    @Size(max = 250, message = "Email cannot be larger than 250")
    private String email;

    @Size(max = 250, message = "mobile cannot be larger than 250")
    private String mobile;

    @Size(max = 250, message = "phone cannot be larger than 250")
    private String phone;

    @NotBlank
    @Size(max = 500, message = "Name cannot be larger than 500")
    private String fullName;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/SugarTypeController.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.business.dataobjects.SugarTypeModel;
import com.theexperts.coffeeappbackend.business.SugarTypeFilter;
import com.theexperts.coffeeappbackend.business.SugarTypeService;
import com.theexperts.coffeeappbackend.web.pages.Page;
import com.theexperts.coffeeappbackend.web.pages.PageSize;
import com.theexperts.coffeeappbackend.web.pages.PagesValidator;
import lombok.AllArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/sugartypes")
@AllArgsConstructor
public class SugarTypeController {
    final SugarTypeService sugarTypeService;

    @GetMapping()
    public List<SugarTypeModel> getSugarTypes(Page page, PageSize pageSize) {
        PagesValidator.DEFAULT.ensureValid(page, pageSize);

        return sugarTypeService.getSugarTypes(SugarTypeFilter.builder()
                .pageSize(pageSize.get())
                .pageNumber(page.get())
                .build());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/OrderController.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.ObjectResult;
import com.theexperts.coffeeappbackend.business.*;
import com.theexperts.coffeeappbackend.business.dataobjects.*;
import com.theexperts.coffeeappbackend.business.contactresolution.ContactResolveContext;
import com.theexperts.coffeeappbackend.business.contactresolution.ContactResolver;
import com.theexperts.coffeeappbackend.web.ValidationException;
import com.theexperts.coffeeappbackend.web.model.OrderCreateRequest;
import com.theexperts.coffeeappbackend.web.pages.Page;
import com.theexperts.coffeeappbackend.web.pages.PageSize;
import com.theexperts.coffeeappbackend.web.pages.PagesValidator;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.Validator;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.*;

import java.util.Arrays;
import java.util.List;

@RestController
@RequestMapping("/orders")
@AllArgsConstructor
public class OrderController {
    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    private final Validator[] validators;

    private final OrderService orderService;
    private final CustomerService customerService;

    private final ContactResolver contactResolver;
    private final ContactService contactService;
    private final NewsletterService newsletterService;

    @InitBinder
    private void setUpValidators(WebDataBinder binder) {
        if (binder.getTarget() == null) {
            return;
        }

        Arrays.stream(validators)
                .filter(x -> x.supports(binder.getTarget().getClass()))
                .filter(x -> x.getClass().getName().startsWith("com.theexperts."))
                .forEach(binder::addValidators);
    }

    @GetMapping()
    public PageResult<OrderModel> getOrders(
            Page page, PageSize pageSize,
            @RequestParam(name = "sortKey", required = false) String sortKey,
            @RequestParam(name = "sortDirection", required = false) String sortDirection,
            @RequestParam(name = "status", required = false) OrderModelStatus status
    ) {
        PagesValidator.DEFAULT.ensureValid(page, pageSize);

        return orderService.getOrders(OrderFilter.builder()
                .status(status)
                .pageSize(pageSize.get())
                .pageNumber(page.get())
                .sortDirection(SortDirection.tryParse(sortDirection).orElse(null))
                .sortKey(sortKey)
                .build());
    }

    @GetMapping("{id}")
    public ResponseEntity<OrderModel> getOrder(@PathVariable(name = "id") Integer id) {
        if (id <= 0) {
            throw ValidationException.create("id", "should be a positive number");
        }

        var result = orderService.getOrder(id);

        return result.map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @GetMapping("count")
    public ResponseEntity<Long> getOrderStatistics() {
        return ResponseEntity.ok(this.orderService.countOrders());
    }

    @PostMapping()
    public ObjectResult<OrderModel> createOrder(@RequestBody @Valid OrderCreateRequest request) throws CustomerNotFoundException {
        var customer = customerService.getCustomer(request.getEmail()).orElse(null);

        if (customer == null) {
            customer = customerService.createCustomer(CustomerCreateModel.builder()
                    .email(request.getEmail())
                    .fullName(request.getFullName())
                    .build());
        } else {
            customer.setEmail(request.getEmail());
            customer.setFullName(request.getFullName());

            customer = customerService.updateCustomer(customer);
        }

        if (customer == null) {
            throw new RuntimeException("Customer could not be resolved");
        }

        if (request.getSubscribe()) {
            var contact = contactResolver.resolve(ContactResolveContext.builder()
                            .email(request.getEmail())
                            .build())
                    .orElse(null);

            if (contact == null) {
                contact = contactService.createContact(ContactCreateModel.builder()
                        .email(request.getEmail())
                        .fullName(request.getFullName())
                        .build());
            }

            try {
                newsletterService.subscribe(contact, true);
            } catch (ContactNotFoundException e) {
                logger.error("Contact not found", e);
            }
        }

        var order = orderService.createOrder(OrderCreateModel.builder()
                .customerEmail(customer.getEmail())
                .orderItems(List.of(OrderItemCreateModel.builder()
                        .productId(request.getProductId())
                        .sugarTypeId(request.getSugarTypeId())
                        .extraTypeIds(request.getExtraTypeIds())
                        .build()))
                .build());

        return ObjectResult.success(order);
    }

    @PostMapping("/{id}/{status}")
    public ObjectResult<OrderModel> updateStatus(@PathVariable(value = "id") Integer id, @PathVariable(value = "status") OrderModelStatus status) throws OrderNotFoundException {
        orderService.updateOrderStatus(id, status);

        return ObjectResult.success(orderService.getOrder(id).orElseThrow());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/ProductController.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.business.dataobjects.ProductModel;
import com.theexperts.coffeeappbackend.business.ProductFilter;
import com.theexperts.coffeeappbackend.business.ProductService;
import com.theexperts.coffeeappbackend.web.ValidationException;
import com.theexperts.coffeeappbackend.web.pages.Page;
import com.theexperts.coffeeappbackend.web.pages.PageSize;
import com.theexperts.coffeeappbackend.web.pages.PagesValidator;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/products")
@AllArgsConstructor
public class ProductController {
    private final ProductService productService;

    @GetMapping()
    public List<ProductModel> getProducts(Page page, PageSize pageSize) {
        PagesValidator.DEFAULT.ensureValid(page, pageSize);

        return productService.getProducts(ProductFilter.builder()
                .pageSize(pageSize.get())
                .pageNumber(page.get())
                .build());
    }

    @GetMapping("{id}")
    public ResponseEntity<ProductModel> getProduct(@PathVariable(name = "id") Integer id) {
        if (id <= 0) {
            throw ValidationException.create("id", "should be a positive number");
        }

        var result = productService.getProduct(id);

        return result.map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/ContactController.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.ObjectResult;
import com.theexperts.coffeeappbackend.business.ContactNotFoundException;
import com.theexperts.coffeeappbackend.business.ContactService;
import com.theexperts.coffeeappbackend.business.dataobjects.ContactCreateModel;
import com.theexperts.coffeeappbackend.business.NewsletterService;
import com.theexperts.coffeeappbackend.business.contactresolution.ContactResolveContext;
import com.theexperts.coffeeappbackend.business.contactresolution.ContactResolver;
import com.theexperts.coffeeappbackend.util.TokenParseException;
import com.theexperts.coffeeappbackend.web.model.AddSubscriptionRequest;
import com.theexperts.coffeeappbackend.web.model.ContactCreateRequest;
import com.theexperts.coffeeappbackend.web.model.RemoveSubscriptionRequest;
import com.theexperts.coffeeappbackend.web.model.SubscriptionRequest;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/contacts")
@AllArgsConstructor
public class ContactController {
    private final ContactResolver contactResolver;
    private final ContactService contactService;
    private final NewsletterService newsletterService;

    @PostMapping()
    public ResponseEntity<ObjectResult> create(@Valid @RequestBody ContactCreateRequest request) {
        var contact = contactResolver.resolve(ContactResolveContext.builder()
                        .email(request.getEmail())
                        .mobile(request.getMobile())
                        .phone(request.getPhone())
                        .build())
                .orElse(null);

        if (contact != null) {
            return ResponseEntity.badRequest().body(ObjectResult.failure("Contact already exists"));
        }

        contact = contactService.createContact(ContactCreateModel.builder()
                .email(request.getEmail())
                .mobile(request.getMobile())
                .phone(request.getPhone())
                .fullName(request.getFullName())
                .build());

        return ResponseEntity.ok(ObjectResult.success(contact));
    }

    @PostMapping("/subscribe")
    public ResponseEntity<Boolean> subscribe(@Valid @RequestBody SubscriptionRequest request) throws ContactNotFoundException {
        var contact = contactResolver.resolve(ContactResolveContext.builder()
                        .email(request.getEmail())
                        .build())
                .orElse(null);

        if (contact == null) {
            throw new ContactNotFoundException();
        }

        newsletterService.subscribe(contact);

        return ResponseEntity.ok(true);
    }

    @PostMapping("/subscription/accept")
    public ResponseEntity<Boolean> acceptSubscription(@Valid @RequestBody AddSubscriptionRequest request) throws ContactNotFoundException {

        try {
            newsletterService.subscribe(request.getToken());
        } catch (ContactNotFoundException | TokenParseException e) {
            return ResponseEntity.badRequest().build();
        }

        return ResponseEntity.ok(true);
    }

    @PostMapping("/unsubscribe")
    public ResponseEntity<Boolean> unsubscribe(@Valid @RequestBody RemoveSubscriptionRequest request) throws ContactNotFoundException {

        try {
            newsletterService.unsubscribe(request.getToken());
        } catch (ContactNotFoundException | TokenParseException e) {
            return ResponseEntity.badRequest().build();
        }

        return ResponseEntity.ok(true);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/ExtraTypeController.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.business.dataobjects.ExtraTypeModel;
import com.theexperts.coffeeappbackend.business.ExtraTypeFilter;
import com.theexperts.coffeeappbackend.business.ExtraTypeService;
import com.theexperts.coffeeappbackend.web.pages.Page;
import com.theexperts.coffeeappbackend.web.pages.PageSize;
import com.theexperts.coffeeappbackend.web.pages.PagesValidator;
import lombok.AllArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/extratypes")
@AllArgsConstructor
public class ExtraTypeController {
    final ExtraTypeService extraTypeService;

    @GetMapping()
    public List<ExtraTypeModel> getExtraTypes(Page page, PageSize pageSize) {
        PagesValidator.DEFAULT.ensureValid(page, pageSize);

        return extraTypeService.getExtraTypes(ExtraTypeFilter.builder()
                .pageSize(pageSize.get())
                .pageNumber(page.get())
                .build());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/OrderCreateRequestValidator.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.business.dataobjects.ExtraTypeModel;
import com.theexperts.coffeeappbackend.business.*;
import com.theexperts.coffeeappbackend.web.model.OrderCreateRequest;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;

@Component
@AllArgsConstructor
class OrderCreateRequestValidator implements Validator {
    final OrderService orderService;
    final ProductService productService;
    final SugarTypeService sugarTypeService;
    final ExtraTypeService extraTypeService;

    @Override
    public boolean supports(Class<?> type) {
        return OrderCreateRequest.class.equals(type);
    }

    @Override
    public void validate(Object target, Errors errors) {
        var request = (OrderCreateRequest) target;

        if (request.getProductId() == null) {
            errors.rejectValue("productId", "", "cannot be null");
        } else {
            var product = productService.getProduct(request.getProductId());
            if (product.isEmpty()) {
                errors.rejectValue("productId", "", "product not found in backing store");
            }
        }

        if (request.getSugarTypeId() == null) {
            errors.rejectValue("sugarTypeId", "", "cannot be null");
        } else {
            var sugarType = sugarTypeService.getSugarType(request.getSugarTypeId());
            if (sugarType.isEmpty()) {
                errors.rejectValue("sugarTypeId", "", "sugarType not found in backing store");
            }
        }

        if (request.getExtraTypeIds() != null && !request.getExtraTypeIds().isEmpty()) {
            var extraTypes = extraTypeService.getExtraTypes(ExtraTypeFilter.builder().pageNumber(1).pageSize(100).build())
                    .stream()
                    .map(ExtraTypeModel::getId)
                    .distinct()
                    .toList();

            var invalid = request.getExtraTypeIds().stream()
                    .anyMatch(x -> !extraTypes.contains(x));

            if (invalid) {
                errors.rejectValue("extraTypeIds", "", "extraType not found in backing store");
            }
        }
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/controller/HeaderMethodArgumentResolverConfiguration.java ---
package com.theexperts.coffeeappbackend.web.controller;

import com.theexperts.coffeeappbackend.web.pages.Page;
import com.theexperts.coffeeappbackend.web.pages.PageSize;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.MethodParameter;
import org.springframework.lang.Nullable;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;
import java.util.Optional;

@Configuration()
public class HeaderMethodArgumentResolverConfiguration implements WebMvcConfigurer {

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(new HandlerMethodArgumentResolver() {
            @Override
            public boolean supportsParameter(MethodParameter parameter) {
                return Page.class.isAssignableFrom(parameter.getParameterType());
            }

            @Override
            public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
                return Optional.ofNullable(webRequest.getParameter(Page.NAME))
                        .map(Page::of)
                        .orElse(Page.DEFAULT);
            }
        });

        resolvers.add(new HandlerMethodArgumentResolver() {
            @Override
            public boolean supportsParameter(MethodParameter parameter) {
                return PageSize.class.isAssignableFrom(parameter.getParameterType());
            }

            @Override
            public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
                return Optional.ofNullable(webRequest.getParameter(PageSize.NAME))
                        .map(PageSize::of)
                        .orElse(PageSize.DEFAULT);
            }
        });
    }
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/ApplicationConfiguration.java ---
package com.theexperts.coffeeappbackend.web;

import com.theexperts.coffeeappbackend.business.AzureServiceBus;
import com.theexperts.coffeeappbackend.business.MessageBus;
import com.theexperts.coffeeappbackend.business.RabbitMQServiceBus;
import com.theexperts.coffeeappbackend.mail.ConsoleMailService;
import com.theexperts.coffeeappbackend.mail.MailService;
import com.theexperts.coffeeappbackend.mail.sendgrid.SendgridMailService;
import com.theexperts.coffeeappbackend.mail.sendgrid.SendgridMailServiceOptions;
import com.theexperts.coffeeappbackend.templates.TemplateService;
import com.theexperts.coffeeappbackend.templates.handlebars.HandlebarsTemplateService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

import java.util.Optional;

@Configuration
public class ApplicationConfiguration {
    @Bean
    public MailService configureMails(Environment environment) {
        var provider = Optional.ofNullable(environment.getProperty("mail.provider")).orElse("").trim().toLowerCase();

        return switch (provider) {
            case "sendgrid" -> new SendgridMailService(SendgridMailServiceOptions.builder()
                    .defaultSenderEmail(environment.getProperty("spring.sendgrid.sender.default"))
                    .apiKey(environment.getProperty("spring.sendgrid.api-key"))
                    .build());
            case "console" -> new ConsoleMailService();
            default -> throw new RuntimeException("Unknown mail provider");
        };
    }

    @Bean
    public TemplateService configureTemplates() {
        return new HandlebarsTemplateService();
    }

    @Bean
    public MessageBus configureMessageBus(Environment environment) {
        var platform = Optional.ofNullable(environment.getProperty("servicebus.platform")).orElse("").trim().toLowerCase();
        var connectionString = environment.getProperty("servicebus.connection-string");

        return switch (platform) {
            case "rabbitmq" -> new RabbitMQServiceBus(connectionString);
            case "azure" -> new AzureServiceBus(connectionString);
            default -> throw new RuntimeException("Unknown message bus platform");
        };
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/responses/ErrorResponse.java ---
package com.theexperts.coffeeappbackend.web.responses;

import java.io.Serializable;
import java.time.LocalDateTime;

public interface ErrorResponse extends Serializable {
    LocalDateTime getTimestamp();

    Integer getStatus();

    String getCode();

    String getMessage();
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/responses/ValidationError.java ---
package com.theexperts.coffeeappbackend.web.responses;

import lombok.Builder;
import lombok.Getter;

import java.io.Serializable;

@Builder
@Getter
public class ValidationError implements Serializable {
    String path;
    String message;

    public static ValidationError create(String path, String message) {
        return ValidationError.builder()
                .path(path)
                .message(message)
                .build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/responses/ValidationErrorResponse.java ---
package com.theexperts.coffeeappbackend.web.responses;

import lombok.Getter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
import java.util.List;

@Getter
public class ValidationErrorResponse implements ErrorResponse {
    private final LocalDateTime timestamp;
    private final Integer status;
    private final String code;
    private final String message;
    private final List<ValidationError> errors;

    protected ValidationErrorResponse(List<ValidationError> errors, HttpStatus status, String message, LocalDateTime timestamp) {
        this.timestamp = timestamp;
        this.status = status.value();
        this.code = status.isError() ? status.getReasonPhrase() : "";
        this.message = message;
        this.errors = errors;
    }

    public static ValidationErrorResponseBuilder builder() {
        return new ValidationErrorResponseBuilder();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/responses/GenericErrorResponse.java ---
package com.theexperts.coffeeappbackend.web.responses;

import lombok.Getter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Getter
public class GenericErrorResponse implements ErrorResponse {
    LocalDateTime timestamp;
    Integer status;
    String code;
    String message;

    protected GenericErrorResponse(HttpStatus status, String message, LocalDateTime timestamp) {
        this.timestamp = timestamp;
        this.status = status.value();
        this.code = status.isError() ? status.getReasonPhrase() : "";
        this.message = message;
    }

    public static ErrorResponseBuilder builder() {
        return new ErrorResponseBuilder();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/responses/ValidationErrorResponseBuilder.java ---
package com.theexperts.coffeeappbackend.web.responses;

import lombok.Data;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
public final class ValidationErrorResponseBuilder {
    ArrayList<ValidationError> errors;
    HttpStatus status;
    String message;
    LocalDateTime timestamp;

    public ValidationErrorResponseBuilder() {
        this.errors = new ArrayList<>();
    }

    public ValidationErrorResponseBuilder errors(List<ValidationError> errors) {
        this.errors.addAll(errors);

        return this;
    }

    public ValidationErrorResponseBuilder status(HttpStatus status) {
        this.status = status;

        return this;
    }

    public ValidationErrorResponseBuilder message(String message) {
        this.message = message;

        return this;
    }

    public ValidationErrorResponseBuilder timestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;

        return this;
    }

    public ValidationErrorResponse build() {
        return new ValidationErrorResponse(errors, status, message, timestamp);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/responses/ErrorResponseBuilder.java ---
package com.theexperts.coffeeappbackend.web.responses;

import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

public final class ErrorResponseBuilder {
    HttpStatus status;
    String message;
    LocalDateTime timestamp;

    ErrorResponseBuilder() {

    }

    public ErrorResponseBuilder status(HttpStatus status) {
        this.status = status;

        return this;
    }

    public ErrorResponseBuilder message(String message) {
        this.message = message;

        return this;
    }

    public ErrorResponseBuilder timestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;

        return this;
    }

    public GenericErrorResponse build() {
        return new GenericErrorResponse(status, message, timestamp);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/SecurityConfiguration.java ---
package com.theexperts.coffeeappbackend.web.security;

import com.theexperts.coffeeappbackend.util.JwtService;
import com.theexperts.coffeeappbackend.util.JwtServiceOptions;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractAuthenticationFilterConfigurer;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.Http403ForbiddenEntryPoint;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfiguration {
    @Bean
    public JwtService jwtService(Environment environment) {
        return new JwtService(JwtServiceOptions
                .builder()
                .issuer(environment.getProperty("jwt.issuer"))
                .secret(environment.getProperty("jwt.secret"))
                .build());
    }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService userDetailsService) {
        return new DefaultAuthenticationManager(userDetailsService, PasswordEncoderFactories.createDelegatingPasswordEncoder());
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, JwtAuthorizationFilter jwtAuthorizationFilter, Environment environment) throws Exception {
        return http
                // Enable CORS and disable CSRF
                .cors(AbstractHttpConfigurer::disable)
                .csrf(AbstractHttpConfigurer::disable)
                // Set session management to stateless
                .sessionManagement(x -> x.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                // Set unauthorized requests exception handle
                .exceptionHandling(x -> x.authenticationEntryPoint(new Http403ForbiddenEntryPoint()))
                // Set permissions on endpoints
                .authorizeHttpRequests(requests ->
                {
                    if (Boolean.TRUE.equals(environment.getProperty("spring.h2.console.enabled", Boolean.class, false))) {
                        requests.requestMatchers(PathRequest.toH2Console()).permitAll();
                    }

                    if (Boolean.TRUE.equals(environment.getProperty("springdoc.swagger-ui.enabled", Boolean.class, false))) {
                        requests.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll();
                    }


                    requests
                            // public endpoints
                            .requestMatchers("/account/authenticate").anonymous()
                            // private endpoints
                            .anyRequest().authenticated();
                })
                .formLogin(AbstractAuthenticationFilterConfigurer::permitAll)
                .headers(headers -> headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin))
                .addFilterBefore(jwtAuthorizationFilter, UsernamePasswordAuthenticationFilter.class)
                .build()
                ;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/DefaultUserDetailsService.java ---
package com.theexperts.coffeeappbackend.web.security;

import com.theexperts.coffeeappbackend.business.UserService;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;

@Service
@AllArgsConstructor
public class DefaultUserDetailsService implements UserDetailsService {
    private final UserService userService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        var user = this.userService.getUser(username).orElse(null);

        if (user == null) {
            throw new UsernameNotFoundException("User not found");
        }

        return IdentityUser.builder()
                .username(user.getUsername())
                .password("{bcrypt}" + user.getPassword())
                .expired(user.getExpired())
                .locked(user.getLocked())
                .enabled(user.getEnabled())
                .build();
    }
}

@Builder
@AllArgsConstructor
class IdentityUser implements UserDetails {
    String username;
    String password;

    boolean expired;
    boolean locked;
    boolean enabled;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return new ArrayList<>();
    }

    @Override
    public String getPassword() {
        return this.password;
    }

    @Override
    public String getUsername() {
        return this.username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return !this.expired;
    }

    @Override
    public boolean isAccountNonLocked() {
        return !this.locked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return !this.expired;
    }

    @Override
    public boolean isEnabled() {
        return this.enabled;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/JwtAuthorizationFilter.java ---
package com.theexperts.coffeeappbackend.web.security;

import com.theexperts.coffeeappbackend.util.JwtService;
import com.theexperts.coffeeappbackend.util.StringUtils;
import com.theexperts.coffeeappbackend.util.TokenParseException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.AllArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@AllArgsConstructor
public class JwtAuthorizationFilter extends OncePerRequestFilter {
    private static final String TOKEN_HEADER = "Authorization";
    private static final String TOKEN_PREFIX = "Bearer";

    private final UserDetailsService userDetailsService;
    private final JwtService jwt;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        var token = resolveToken(request);

        if (StringUtils.isNullOrEmpty(token)) {
            filterChain.doFilter(request, response);

            return;
        }

        try {
            var claims = this.jwt.parseToken(token);

            var user = userDetailsService.loadUserByUsername(claims.getSubject());

            var authentication = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        } catch (UsernameNotFoundException | TokenParseException e) {
            // do nothing
        }

        filterChain.doFilter(request, response);
    }

    private static String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader(TOKEN_HEADER);

        if (bearerToken != null && bearerToken.startsWith(TOKEN_PREFIX)) {
            return bearerToken.substring(TOKEN_PREFIX.length()).trim();
        }

        return null;
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/web/model/AuthenticationRequest.java ---
package com.theexperts.coffeeappbackend.web.security.web.model;

import lombok.Data;

import java.io.Serializable;

@Data
public class AuthenticationRequest implements Serializable {
    private String username;
    private String password;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/web/model/ResetPasswordRequest.java ---
package com.theexperts.coffeeappbackend.web.security.web.model;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

import java.io.Serializable;

@Data
public class ResetPasswordRequest implements Serializable {
    @NotEmpty
    @NotBlank
    String username;
    @NotEmpty
    @NotBlank
    String password;

    @NotEmpty
    @NotBlank
    String resetToken;
}

--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/web/model/UserCreateRequest.java ---
package com.theexperts.coffeeappbackend.web.security.web.model;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

import java.io.Serializable;

@Data
public class UserCreateRequest  implements Serializable {
    @NotEmpty
    @NotBlank
    String username;
    @NotEmpty
    @NotBlank
    String password;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/web/AuthenticationController.java ---
package com.theexperts.coffeeappbackend.web.security.web;

import com.theexperts.coffeeappbackend.business.dataobjects.UserCreateModel;
import com.theexperts.coffeeappbackend.business.UserNotFoundException;
import com.theexperts.coffeeappbackend.business.UserService;
import com.theexperts.coffeeappbackend.util.JwtService;
import com.theexperts.coffeeappbackend.web.security.web.model.AuthenticationRequest;
import com.theexperts.coffeeappbackend.web.security.web.model.ResetPasswordRequest;
import com.theexperts.coffeeappbackend.web.security.web.model.UserCreateRequest;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/account")
@AllArgsConstructor
public class AuthenticationController {
    private final UserService userService;
    private final AuthenticationManager authenticationManager;
    private final JwtService jwt;

    @PostMapping("/authenticate")
    public ResponseEntity<Object> authenticateUser(@Valid @RequestBody AuthenticationRequest authenticationRequest) {
        var token = new UsernamePasswordAuthenticationToken(authenticationRequest.getUsername(), authenticationRequest.getPassword());
        var authentication = authenticationManager.authenticate(token);

        if (!authentication.isAuthenticated()) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        SecurityContextHolder.getContext().setAuthentication(authentication);

        var claims = jwt.claimsBuilder()
                .subject(authenticationRequest.getUsername())
                .add("scope", "self api/buy")
                .build();

        return ResponseEntity.ok().body(jwt.generateToken(claims));
    }

    @PostMapping("/create")
    public ResponseEntity<Object> createUser(@Valid @RequestBody UserCreateRequest request) {
        var user = userService.getUser(request.getUsername()).orElse(null);

        if (user != null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
        }

        userService.createUser(UserCreateModel.builder()
                .username(request.getUsername())
                .password(request.getPassword())
                .build());

        return ResponseEntity.ok().build();
    }

    @PostMapping("/reset")
    public ResponseEntity<Object> resetPassword(@Valid @RequestBody ResetPasswordRequest request) {
        try {
            var user = userService.getUser(request.getUsername()).orElseThrow();

            if (!user.getResetToken().equals(request.getResetToken())) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
            }

            user.setPassword(request.getPassword());
            user.setResetToken(null);

            userService.updateUser(user);
        } catch (UserNotFoundException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("User not found");
        }

        return ResponseEntity.ok().build();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/web/security/DefaultAuthenticationManager.java ---
package com.theexperts.coffeeappbackend.web.security;

import lombok.AllArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;

@AllArgsConstructor
class DefaultAuthenticationManager implements AuthenticationManager {
    private final UserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        var username = authentication.getName();
        var password = authentication.getCredentials().toString();

        var user = userDetailsService.loadUserByUsername(username);

        if(user == null) {
            throw new BadCredentialsException("Authentication failed");
        }

        if (passwordEncoder.matches(password, user.getPassword())) {
            return new UsernamePasswordAuthenticationToken(user, password, user.getAuthorities());
        }

        throw new BadCredentialsException("Authentication failed");
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/ObjectResult.java ---
package com.theexperts.coffeeappbackend;

import lombok.Getter;
import lombok.Setter;

@Getter
public class ObjectResult<T> {
    boolean success;

    @Setter
    T data;

    protected ObjectResult(boolean success, T data) {
        this.success = success;
        this.data = data;
    }

    public static <T> ObjectResult<T> success() {
        return ObjectResult.success(null);
    }

    public static <T> ObjectResult<T> success(T data) {
        return new ObjectResult<>(true, data);
    }

    public static <T> ObjectResult<T> failure() {
        return ObjectResult.failure(null);
    }

    public static <T> ObjectResult<T> failure(T data) {
        return new ObjectResult<>(false, data);
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/util/TokenParseException.java ---
package com.theexperts.coffeeappbackend.util;

public class TokenParseException extends Exception {
    public TokenParseException() {
        super("could not parse token");
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/util/JwtService.java ---
package com.theexperts.coffeeappbackend.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ClaimsBuilder;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Encoders;
import io.jsonwebtoken.security.Keys;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Date;
import java.util.Objects;
import java.util.stream.Stream;

public class JwtService {
    private static final String[] SECRET_PREFIXES = new String[]{
            JwtService.class.getCanonicalName()
    };

    private final JwtServiceOptions options;

    public JwtService(JwtServiceOptions options) {
        Objects.requireNonNull(options, "options must not be null");

        this.options = options;
    }

    public ClaimsBuilder claimsBuilder() {
        return Jwts.claims();
    }

    public String generateToken(Claims claims, String... keys) {
        Objects.requireNonNull(claims, "claims must not be null");

        var issuedAt = claims.getIssuedAt() != null
                ? claims.getIssuedAt().toInstant()
                : Instant.now();
        var notBefore = claims.getNotBefore() != null
                ? claims.getNotBefore().toInstant()
                : issuedAt;
        var expiresAt = claims.getExpiration() != null
                ? claims.getExpiration().toInstant()
                : LocalDateTime.ofInstant(issuedAt, ZoneOffset.ofHours(0))
                .plusYears(1)
                .atZone(ZoneOffset.ofHours(0))
                .toInstant();

        if (notBefore.isBefore(issuedAt)) {
            throw new RuntimeException("notBefore must be after or exactly at issuedAt");
        }

        var requestKeys = Stream
                .concat(Stream.of(this.options.getSecret()), Stream.of(keys))
                .filter(x -> !StringUtils.isNullOrEmpty(x))
                .toArray(String[]::new);

        return Jwts.builder()
                .claims(claims)
                .issuer(this.options.getIssuer())
                .issuedAt(Date.from(issuedAt))
                .notBefore(Date.from(notBefore))
                .expiration(Date.from(expiresAt))
                .signWith(Keys.hmacShaKeyFor(getSecret(requestKeys).getBytes(StandardCharsets.UTF_8)))
                .compact();
    }

    public Claims parseToken(String token, String... keys) throws TokenParseException {
        if (StringUtils.isNullOrEmpty(token)) {
            throw new TokenParseException();
        }

        var requestKeys = Stream
                .concat(Stream.of(this.options.getSecret()), Stream.of(keys))
                .filter(x -> !StringUtils.isNullOrEmpty(x))
                .toArray(String[]::new);

        var parser = Jwts.parser()
                .verifyWith(Keys.hmacShaKeyFor(getSecret(requestKeys).getBytes(StandardCharsets.UTF_8)))
                .build();

        Claims claims;

        try {
            claims = parser.parseSignedClaims(token).getPayload();
        } catch (JwtException e) {
            throw new TokenParseException();
        }

        if (!claims.getIssuer().equalsIgnoreCase(this.options.getIssuer())) {
            throw new TokenParseException();
        }

        var now = Date.from(Instant.now());

        var valid = claims.getIssuedAt().before(now)
                && claims.getNotBefore().before(now)
                && claims.getExpiration().after(now);

        if (!valid) {
            throw new TokenParseException();
        }

        return claims;
    }

    private static String getSecret(String... keys) {
        var finalKeys = Stream
                .concat(Stream.of(SECRET_PREFIXES), Stream.of(keys))
                .filter(x -> !StringUtils.isNullOrEmpty(x))
                .toArray(String[]::new);

        var finalKey = String.join("::", finalKeys);

        return Encoders.BASE64.encode(finalKey.getBytes());
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/util/JwtServiceOptions.java ---
package com.theexperts.coffeeappbackend.util;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class JwtServiceOptions {
    private String issuer;
    private String secret;
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/src/main/java/com/theexperts/coffeeappbackend/util/StringUtils.java ---
package com.theexperts.coffeeappbackend.util;

public final class StringUtils {
    private StringUtils() {
    }
    
    public static boolean isNullOrEmpty(String text) {
        return text == null || text.isEmpty();
    }
}
--- /home/pkonstantellos/git/coffee-app/coffee-app-api/coffee-app-backend/pom.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.the-experts</groupId>
        <artifactId>coffee-app</artifactId>
        <version>0.0.1-local</version>
    </parent>

    <artifactId>coffee-app-backend</artifactId>
    <packaging>jar</packaging>

    <name>coffee-app backend</name>
    <description>Backend Web App for Coffee App</description>
    <url>https://the-experts.com</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>

        <spring.version>3.3.5</spring.version>
        <jjwt.version>0.12.6</jjwt.version>
        <spring.doc.version>2.6.0</spring.doc.version>
        <springdoc-openapi-maven-plugin.version>1.4</springdoc-openapi-maven-plugin.version>
        <mariadb.version>3.5.0</mariadb.version>
        <mssql-jdbc.version>12.8.1.jre11</mssql-jdbc.version>
        <flywaydb.version>10.20.1</flywaydb.version>
        <sendgrid.version>4.10.3</sendgrid.version>
        <handlebars.version>4.4.0</handlebars.version>
        <rabbitmq.version>5.22.0</rabbitmq.version>
        <azure-messaging-servicebus.version>7.17.5</azure-messaging-servicebus.version>
        <archunit.version>1.3.0</archunit.version>
        <sonar.exclusions>
            **/src/main/java/com/theexperts/coffee-app-backend/persistence/entities/**,
            **/src/main/java/com/theexperts/coffee-app-backend/web/model/**,
            **/src/main/java/com/theexperts/coffee-app-backend/web/Security/web/Model/**,
            **/src/main/java/com/theexperts/coffee-app-backend/persistence/Constants.java,
            **/src/main/java/com/theexperts/coffee-app-backend/business/DataObjects/**,
            **/src/main/java/com/theexperts/coffee-app-backend/web/responses/**
        </sonar.exclusions>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mariadb.jdbc</groupId>
            <artifactId>mariadb-java-client</artifactId>
            <version>${mariadb.version}</version>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${spring.doc.version}</version>
        </dependency>
        <dependency>
            <groupId>com.microsoft.sqlserver</groupId>
            <artifactId>mssql-jdbc</artifactId>
            <version>${mssql-jdbc.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
            <version>${flywaydb.version}</version>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-mysql</artifactId>
            <version>${flywaydb.version}</version>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-sqlserver</artifactId>
            <version>${flywaydb.version}</version>
        </dependency>
        <dependency>
            <groupId>com.sendgrid</groupId>
            <artifactId>sendgrid-java</artifactId>
            <version>${sendgrid.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.jknack</groupId>
            <artifactId>handlebars</artifactId>
            <version>${handlebars.version}</version>
        </dependency>
        <dependency>
            <groupId>com.azure</groupId>
            <artifactId>azure-messaging-servicebus</artifactId>
            <version>${azure-messaging-servicebus.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-gson</artifactId> <!-- jwt-jackson or jjwt-gson if Gson is preferred -->
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.rabbitmq</groupId>
            <artifactId>amqp-client</artifactId>
            <version>${rabbitmq.version}</version>
        </dependency>
        <dependency>
            <groupId>com.tngtech.archunit</groupId>
            <artifactId>archunit-junit5</artifactId>
            <version>${archunit.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>prepare-agent</id>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                        <configuration>
                            <mainClass>com.theexperts.coffeeappbackend.Application</mainClass>
                        </configuration>
                    </execution>
                    <execution>
                        <id>pre-integration-test</id>
                        <goals>
                            <goal>start</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>post-integration-test</id>
                        <goals>
                            <goal>stop</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springdoc</groupId>
                <artifactId>springdoc-openapi-maven-plugin</artifactId>
                <version>${springdoc-openapi-maven-plugin.version}</version>
                <executions>
                    <execution>
                        <phase>integration-test</phase>
                        <goals>
                            <goal>generate</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <apiDocsUrl>http://localhost:8090/v3/api-docs</apiDocsUrl>
                    <outputFileName>openapi.json</outputFileName>
                    <outputDir>${project.basedir}</outputDir>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.cyclonedx</groupId>
                <artifactId>cyclonedx-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>